<html lang="en">
<head>
<title>JSON</title>
 <meta name="keywords" content="CowTalk" />
 <meta name="description" content="CowTalk - Moo-able Type for Cowtowncoder.com" />

 
<style type="text/css">
@import url('../stylesheets/iconic/iconic-style.css');

/************** REMOVE THIS TO UNHIDE THE BLOGGER NAVBAR ****************
**/       #b-navbar {height:0px;visibility:hidden;display:none}       /**
*************************************************************************

body {margin-top: 32px !important}
*/

/* Let's not hide list markers... */
UL { list-style-type: disc; margin: 6; }
/* Also, better display for code: */
pre { overflow: auto; }

</style>
<script type="text/javascript" src="http://googlelite.free.fr/player.js"></script>
<script type="text/javascript">
window.google_analytics_uacct = "UA-140287-10";
</script>
</head>
<body class="layout-two-column-right">
     <div id="container">
          <div id="container-inner" class="pkg">
<!-- banner -->
<div id="banner">
     <div id="banner-inner" class="pkg">
          <h1 id="banner-header"><a href="http://www.cowtowncoder.com/blog/blog.html" accesskey="1">CowTalk</a></h1>
          <h2 id="banner-description">Moo-able Type for Cowtowncoder.com</h2>
     </div>
</div>
               <div id="pagebody">
                    <div id="pagebody-inner" class="pkg">
                         <div id="alpha">
                              <div id="alpha-inner" class="pkg">
<!-- entry -->

   
     <h2 class="date-header">Saturday, August 18, 2012 </h2>
<div class="entry" id="post-477">
     <h3 class="entry-header">Replacing standard JDK serialization using Jackson (JSON/Smile), java.io.Externalizable</h3>
     
     <div class="entry-content">
          <div class="entry-body">
               <p><p>
      <b>1. Background</b>
    </p>
    <p>
      The default Java serialization provided by JDK is a two-edged sword: on 
      one hand, it is a simple, convenient way to &quot;freeze and thaw&quot; Objects 
      you have, handling about any kind of Java object graphs. It is possibly 
      the most powerful serialization mechanism on Java platform, bar none.
    </p>
    <p>
      But on the other hand, its shortcomings are well-document (and I hope, 
      well-known) at this point. Problems include:
    </p>
    <ul>
      <li>
        Poor space-efficiency (especially for small data), due to inclusion of 
        all class metadata: that is, size of output can be huge, larger than 
        about any alternative, including XML
      </li>
      <li>
        Poor performance (especially for small data), partly due to size 
        inefficiency
      </li>
      <li>
        Brittleness: smallest changes to class definitions may break 
        compatibility, preventing deserialization. This makes it a poor choice 
        for both data exchange between (Java) systems as well as long-term 
        storage
      </li>
    </ul>
    <p>
      Still, the convenience factor has led to many systems using JDK 
      serialization to be the default serialization method to use.
    </p>
    <p>
      Is there anything we could do to address downsides listed above? Plenty, 
      actually. Although there is no way to do much more for the default 
      implementation (JDK serialization implementation is in fact ridiculously 
      well optimized for what it tries to achieve -- it's just that the goal 
      is very ambitious), one can customize what gets used by making objects 
      implement j<b>ava.io.Externalizable</b> interface. If so, JDK will 
      happily use alternate implementation under the hood.
    </p>
    <p>
      Now: although writing custom serializers may be fun sometimes -- and for 
      specific case, you can actually write very efficient solution as well, 
      given enough time -- it would be nice if you could use an existing 
      component to address listed short-comings.
    </p>
    <p>
      And that's what we'll do! Here's one possible way to improve on all 
      problems listed above:
    </p>
    <ol>
      <li>
        Use an efficient Jackson serializer (to produce either JSON, or 
        perhaps more interestingly, <a href="http://wiki.fasterxml.com/SmileFormat">Smile</a> 
        binary data)
      </li>
      <li>
        Wrap it in nice java.io.Externalizable, to make it transparent to code 
        using JDK serialization (albeit not transparent for maintainers of the 
        class -- but we will try minimizing amount of intrusive code)
      </li>
    </ol>
    <p>
      <b>2. Challenges with java.io.Externalizable</b>
    </p>
    <p>
      First things first: while conceptually simple, there are couple of 
      rather odd design decisions that make use of java.io.Externalizable bit 
      tricky:
    </p>
    <ol>
      <li>
        Instead of passing instances of <b>java.io.InputStream</b>, <b>java.io.OutputStream</b>, 
        instead <b>java.io.ObjectOutput</b> and <b>java.io.ObjectInput</b> are 
        used; and they do NOT extend stream versions (even though they define 
        mostly same methods!). This means additional wrapping is needed
      </li>
      <li>
        <b>Externalizable.readExternal()</b> requires updating of the object 
        itself, not that of constructing new instances: most serialization 
        frameworks do not support such operation
      </li>
      <li>
        How to access external serialization library, as no context is passed 
        to either of methods?
      </li>
    </ol>
    <p>
      These are not fundamental problems for Jackson: first one requires use 
      of adapter classes (see below), second that we need to use &quot;updating 
      reader&quot; approach that Jackson was supported for a while (yay!). And to 
      solve the third part, we have at least two choices: use of ThreadLocal 
      for passing an ObjectMapper; or, use of a static helper class (approach 
      shown below)
    </p>
    <div>
      
    </div>
    <div>
      So here are the helper classes we need:
    </div>
    <div>
      <hr>
      
    </div>
    <pre>final static class ExternalizableInput extends InputStream
{
  private final ObjectInput in;

  public ExternalizableInput(ObjectInput in) {
   this.in = in;
  }

  @Override
  public int available() throws IOException {
    return in.available();
  }

  @Override
  public void close() throws IOException {
    in.close();
  }

  @Override
  public boolean  markSupported() {
    return false;
  }

  @Override
  public int read() throws IOException {
   return in.read();
  }

  @Override
  public int read(byte[] buffer) throws IOException {
    return in.read(buffer);
  }

  @Override
  public int read(byte[] buffer, int offset, int len) throws IOException {
    return in.read(buffer, offset, len);
  }

  @Override
  public long skip(long n) throws IOException {
   return in.skip(n);
  }
}<br><br>final static class ExternalizableOutput extends OutputStream
{
  private final ObjectOutput out;

  public ExternalizableOutput(ObjectOutput out) {
   this.out = out;
  }

@Override
public void flush() throws IOException {
out.flush();
}

@Override
public void close() throws IOException {
out.close();
}

@Override
public void write(int ch) throws IOException {
out.write(ch);
}

@Override
public void write(byte[] data) throws IOException {
out.write(data);
}

@Override
public void write(byte[] data, int offset, int len) throws IOException {
out.write(data, offset, len);
}
}<br><br>/* Use of helper class here is unfortunate, but necessary; alternative would<br> * be to use ThreadLocal, and set instance before calling serialization.<br> * Benefit of that approach would be dynamic configuration; however, this<br> * approach is easier to demonstrate.<br> */<br>class MapperHolder {
  private final ObjectMapper mapper = new ObjectMapper();
  private final static MapperHolder instance = new MapperHolder();
  public static ObjectMapper mapper() { return instance.mapper; }
}<br></pre>
    <hr>
    

    <p>
      and given these classes, we can implement 
      Jackson-for-default-serialization solution.
    </p>
    <p>
      <b>3. Let's Do a Serialization!</b>
    </p>
    <p>
      So with that, here's a class that is serializable using Jackson JSON 
      serializer:
    </p>
    <hr>
    

    <pre>  static class MyPojo implements Externalizable
  {
        public int id;
        public String name;
        public int[] values;

        public MyPojo() { } // for deserialization
        public MyPojo(int id, String name, int[] values)
        {
            this.id = id;
            this.name = name;
            this.values = values;
        }

        public void readExternal(ObjectInput in) throws IOException {
            MapperHolder.mapper().readerForUpdating(this).readValue(new ExternalizableInput(in));<br>        }
        public void writeExternal(ObjectOutput oo) throws IOException {
            MapperHolder.mapper().writeValue(new ExternalizableOutput(oo), this);
        }<br>  }
</pre>
    <hr>
    

    <p>
      to use that class, use JDK serialization normally:
    </p>
    <div>
      <hr>
      
    </div>
    <pre>  // serialize as bytes (to demonstrate):<br>  MyPojo input = new MyPojo(13, &quot;Foobar&quot;, new int[] { 1, 2, 3 } );
  ByteArrayOutputStream bytes = new ByteArrayOutputStream();
  ObjectOutputStream obs = new ObjectOutputStream(bytes);
  obs.writeObject(input);
  obs.close();
  byte[] ser = bytes.toByteArray();<br><br>  // and to get it back:<br>  ObjectInputStream ins = new ObjectInputStream(new ByteArrayInputStream(ser));
  MyPojo output = (MyPojo) ins.readObject();<br>  ins.close();</pre>
    <hr>
    

    <p>
      And that's it.
    </p>
    <p>
      <b>4. So what's the benefit?</b>
    </p>
    <p>
      At this point, you may be wondering if and how this would actually help 
      you. Since JDK serialization is using binary format; and since 
      (allegedly!) textual formats are generally more verbose than binary 
      formats, how could this possibly help with size of performance?
    </p>
    <p>
      Turns out that if you test out code above and compare it with the case 
      where class does NOT implement Externalizable, sizes are:
    </p>
    <ul>
      <li>
        Default JDK serialization: 186 bytes
      </li>
      <li>
        Serialization as embedded JSON: 130 bytes
      </li>
    </ul>
    <p>
      Whoa! Quite unexpected result? JSON-based alternative <i>30% SMALLER</i> 
      than JDK serialization!
    </p>
    <p>
      Actually, not really. The problem with JDK serialization is not the way 
      data is stored, but rather the fact that in addition to (compact) data, 
      much of Class definition metadata is included. This metadata is needed 
      to guard against Class incompatibilities (which it can do pretty well), 
      but it comes with a cost. And that cost is particularly high for small 
      data.
    </p>
    <p>
      Similarly, performance typically follows data size: while I don't have 
      publishable results (I may do that for a future post), I expect 
      embedded-JSON to also perform significantly better for single-object 
      serialization use cases.
    </p>
    <p>
      <b>5. Further ideas: Smile!</b>
    </p>
    <p>
      But perhaps you think we should be able to do better, size-wise (and 
      perhaps performance) than using JSON?
    </p>
    <p>
      Absolutely. Since the results are not exactly readable (to use 
      Externalizable, bit of binary data will be used to indicate class name, 
      and little bit of stream metadata), we probably do not greatly care what 
      the actual underlying format is.<br>With this, an obvious choice would 
      be to use <a href="http://wiki.fasterxml.com/SmileFormat">Smile data 
      format</a>, binary counterpart to JSON, a format that Jackson supports 
      100% with <a href="https://github.com/FasterXML/jackson-dataformat-smile">Smile 
      Module</a>.
    </p>
    <p>
      The only change that is needed is to replace the first line from 
      &quot;MapperHolder&quot; to read:
    </p>
    <p>
       <i> private final ObjectMapper mapper = new ObjectMapper(new 
      SmileFactory());</i>
    </p>
    <p>
      and we will see even reduced size, as well as faster reading and writing 
      -- Smile is typically 30-40% smaller in size, and 30-50% faster to 
      process than JSON.
    </p>
    <p>
      <b>6. Even More compact? Consider Jackson 2.1, &quot;POJO as array!&quot;</b>
    </p>
    <p>
      But wait! In very near future, we may be able to do EVEN BETTER! Jackson 
      2.1 (see the <a href="https://github.com/FasterXML/jackson-docs/wiki/Presentation-Jackson-2.1-Preview">Sneak 
      Peek</a>) will introduce one interesting feature that will further 
      reduce size of JSON/Smile Object serialization. By using following 
      annotation:
    </p>
    <p>
        <i>@JsonFormat(shape=JsonFormat.Shape.OBJECT)   </i>
    </p>
    <p>
      you can further reduce the size: this occurs as the property names are 
      excluded from serialization (think of output similar to CSV, just using 
      JSON Arrays).
    </p>
    <p>
      For our toy use case, size is reduced further from 130 bytes to 109; 
      further reduction of almost 20%. But wait! It gets better -- same will 
      be true for Smile as well, since while it can reduce space in general, 
      it still has to retain some amount of name information normally; but 
      with POJO-as-Arrays it will use same exclusion!
    </p>
    <p>
      <b>7. But how about actual real-life results?</b>
    </p>
    <p>
      At this point I am actually planning on doing something based on code I 
      showed above. But planning is in early stages so I do not yet have 
      results from &quot;real data&quot;; meaning objects of more realistic sizes. But I 
      hope to get that soon: the use case is that of storing entities (data 
      for which is read from DB) in memcache. Existing system is getting 
      CPU-bound both from basic serialization/deserialization activity, but 
      especially from higher number of GCs. I fully expect the new approach to 
      help with this; and most importantly, be quite easy to deploy: this 
      because I do not have to change any of code that actually 
      serializes/deserializes Beans -- I just have to modify Beans themselves 
      a bit.
    </p>
    <p>
      
    </p>
    <p>
      
    </p></p>
     <p class="entry-footer">
          <span class="post-footers">Posted by Tatu Saloranta  at Saturday, August 18, 2012 4:26 PM </span>
<br />     Categories: <a href="http://www.cowtowncoder.com/blog/archives/cat_java.html">Java</a>, <a href="http://www.cowtowncoder.com/blog/archives/cat_json.html">JSON</a>, <a href="http://www.cowtowncoder.com/blog/archives/cat_performance.html">Performance</a>
<br />
<span class="separator">|</span> <a class="permalink" href="http://www.cowtowncoder.com/blog/archives/2012/08/entry_477.html">Permalink</a>
<span class="separator">|</span><a href="http://www.cowtowncoder.com/blog/archives/2012/08/entry_477.html#disqus_thread">Comments</a>
<BlogItemBacklinksEnabled> | <a href="http://www.cowtowncoder.com/blog/archives/2012/08/entry_477.html#links">links to this post</a></BlogItemBacklinksEnabled> 

     </p>
          </div>
     </div>
</div>
   
     <h2 class="date-header"> </h2>
<div class="entry" id="post-476">
     <h3 class="entry-header">Forcing escaping of HTML characters (less-than, ampersand) in JSON using Jackson</h3>
     
     <div class="entry-content">
          <div class="entry-body">
               <p><p>
      <b>1. The problem</b>
    </p>
    <p>
      <a href="http://wiki.fasterxml.com/JacksonHome">Jackson</a> handles 
      escaping of JSON String values in minimal way using escaping where 
      absolutely necessary: it escapes two characters by default -- double 
      quotes and backslash -- as well as non-visible control characters. But 
      it does not escape other characters, since this is not required for 
      producing valid JSON documents.
    </p>
    <p>
      There are systems, however, that may run into problems with some 
      characters that are valid in JSON documents. There are also use cases 
      where you might prefer to add more escaping. For example, if you are to 
      enclose a JSON fragment in XML attribute (or Javascript code), you might 
      want to use apostrophe (') as quote character in XML, and force escaping 
      of all apostrophes in JSON content; this allows you to simple embed 
      encoded JSON value without other transformations.
    </p>
    <p>
      Another specific use case is that of escaping &quot;HTML funny characters&quot;, 
      like less-than, greater-than, ampersand and apostrophe characters 
      (double-quote are escaped by default).
    </p>
    <p>
      Let's see how you can do that with Jackson.
    </p>
    <p>
      <b>2. Not as easy to change as you might think</b>
    </p>
    <p>
      Your first thought may be that of &quot;I'll just do it myself&quot;. The problem 
      is two-fold:
    </p>
    <ol>
      <li>
        When using API via data-binding, or regular Streaming generator, you 
        must pass unescaped String, and it will get escaped using Jackson's 
        escaping mechanism -- you can not pre-process it (*)
      </li>
      <li>
        If you decide to post-process content after JSON gets written, you 
        need to be careful with replacements, and this will have negative 
        impact on performance (i.e. it is likely to double time serialization 
        takes)
      </li>
    </ol>
    <p>
      (*) actually, there is method 'JsonGenerator.writeRaw(...)' which you 
      can use to force exact details, but its use is cumbersome and you can 
      easily break things if you are not careful. Plus it is only applicable 
      via Streaming API
    </p>
    <p>
      <b>3. Jackson (1.8) has you covered</b>
    </p>
    <p>
      Luckily, there is no need for you to write custom post-processing code 
      to change details of content escaping.
    </p>
    <p>
      Version 1.8 of Jackson added a feature to let users customize details of 
      escaping of characters in JSON String values.<br>This is done by 
      defining a <b>CharacterEscapes</b> object to be used by <b>JsonGenerator</b>; 
      it is registered on <b>JsonFactory</b>. If you use data-binding, you can 
      set this by using <b>ObjectMapper.getJsonFactory()</b> first, then 
      define CharacterEscapes to use.
    </p>
    <p>
      Functionality is handled at low-level, during writing of JSON String 
      values; and CharacterEscapes abstract class is designed in a way to 
      minimize performance overhead.<br>While there is some performance 
      overhead (little bit of additional processing is required), it should 
      not have significant impact unless significant portion of content 
      requires escaping.<br>As usual, if you care a lot about performance, you 
      may want to measure impact of the change with test data.
    </p>
    <p>
      <b>4. The Code</b>
    </p>
    <p>
      Here is a way to force escaping of HTML &quot;funny characters&quot;, using 
      functionality Jackson 1.8 (and above) have.
    </p>
    <hr>
    

    <pre>import org.codehaus.jackson.SerializableString;
import org.codehaus.jackson.io.CharacterEscapes;
<br>// First, definition of what to escape
public class HTMLCharacterEscapes extends CharacterEscapes
{
    private final int[] asciiEscapes;
    
    public HTMLCharacterEscapes()
    {<br>        // start with set of characters known to require escaping (double-quote, backslash etc)
        int[] esc = CharacterEscapes.standardAsciiEscapesForJSON();<br>        // and force escaping of a few others:
        esc['&lt;'] = CharacterEscapes.ESCAPE_STANDARD;
        esc['&gt;'] = CharacterEscapes.ESCAPE_STANDARD;
        esc['&amp;'] = CharacterEscapes.ESCAPE_STANDARD;
        esc['\''] = CharacterEscapes.ESCAPE_STANDARD;
        asciiEscapes = esc;
    }<br>    // this method gets called for character codes 0 - 127
    @Override public int[] getEscapeCodesForAscii() {
        return asciiEscapes;
    }<br>    // and this for others; we don't need anything special here
    @Override public SerializableString getEscapeSequence(int ch) {
        // no further escaping (beyond ASCII chars) needed:
        return null;
    }
}<br><br>// and then an example of how to apply it<br>public ObjectMapper getEscapingMapper() {<br>    ObjectMapper mapper = new ObjectMapper();<br>    mapper.getJsonFactory().setCharacterEscapes(new HTMLCharacterEscapes());<br>    return mapper;<br>}<br><br>// so we could do:<br>public byte[] serializeWithEscapes(Object ob) throws IOException<br>{<br>    return getEscapingMapper().writeValueAsBytes(ob);<br>}<br><br></pre>
    <hr>
    

    <p>
      And that's it.
    </p></p>
     <p class="entry-footer">
          <span class="post-footers">Posted by Tatu Saloranta  at Saturday, August 18, 2012 3:14 PM </span>
<br />     Categories: <a href="http://www.cowtowncoder.com/blog/archives/cat_json.html">JSON</a>
<br />
<span class="separator">|</span> <a class="permalink" href="http://www.cowtowncoder.com/blog/archives/2012/08/entry_476.html">Permalink</a>
<span class="separator">|</span><a href="http://www.cowtowncoder.com/blog/archives/2012/08/entry_476.html#disqus_thread">Comments</a>
<BlogItemBacklinksEnabled> | <a href="http://www.cowtowncoder.com/blog/archives/2012/08/entry_476.html#links">links to this post</a></BlogItemBacklinksEnabled> 

     </p>
          </div>
     </div>
</div>
   
     <h2 class="date-header">Thursday, May 03, 2012 </h2>
<div class="entry" id="post-474">
     <h3 class="entry-header">Jackson Data-binding: Did I mention it can do YAML as well?</h3>
     
     <div class="entry-content">
          <div class="entry-body">
               <p><p>
      Note: as useful earlier articles, consider reading &quot;<a href="http://www.cowtowncoder.com/blog/archives/2012/03/entry_468.html">Jackson 
      2.0: CSV-compatible as well</a>&quot; and &quot;<a href="http://www.cowtowncoder.com/blog/archives/2012/03/entry_467.html">Jackson 
      2.0: now with XML, too!</a>&quot;
    </p>
    <p>
      <b>1. Inspiration</b>
    </p>
    <p>
      Before jumping into the actual beef -- the new module -- I want to 
      mention my inspiration for this extension: the Greatest New Thing to hit 
      Java World Since JAX-RS called <a href="https://github.com/codahale/dropwizard">DropWizard</a>.
    </p>
    <p>
      For those who have not yet tried it out and are unaware of its Kung-Fu 
      Panda like Awesomeness, please go and check it out. You won't be 
      disappointed.
    </p>
    <p>
      DropWizard is a sort of mini-framework that combines great Java 
      libraries (I may be biased, as it does use Jackson), starting with 
      trusty JAX-RS/Jetty8 combination, building with Jackson for JSON, jDBI 
      for DB/JDBC/SQL, Java Validation API (impl from Hibernate project) for 
      data validation, and logback for logging; adding bit of Jersey-client 
      for client-building and optional FreeMarker plug-in for UI, all bundled 
      up in a nice, modular and easily understandable packet.<br>Most 
      importantly, it &quot;Just Works&quot; and comes with intuitive configuration and 
      bootstrapping system. It also builds easily into a single deployable jar 
      file that contains all the code you need, with just a bit of Maven 
      setup; all of which is well documented. Oh, and the documentation is 
      very accessible, accurate and up-to-date. All in all, a very rare 
      combination of things -- and something that would give RoR and other 
      &quot;easier than Java&quot; frameworks good run for their money, if hipsters ever 
      decided to check out the best that Java has to offer.
    </p>
    <p>
      The most relevant part here is the configuration system. Configuration 
      can use either basic JSON or full YAML. And as I <a href="http://www.cowtowncoder.com/blog/archives/2012/04/entry_473.html">mentioned 
      earlier</a>, I am beginning to appreciate YAML for configuring things.
    </p>
    <p>
      <b>1.1. The Specific inspirational nugget: YAML converter</b>
    </p>
    <p>
      The way DropWizard uses YAML is to parse it using SnakeYAML library, 
      then convert resulting document into JSON tree and then using Jackson 
      for data binding. This is useful since it allows one to use full power 
      of Jackson configuration including annotations and polymorphic type 
      handling.
    </p>
    <p>
      But this got me thinking -- given that the whole converter 
      implementation about dozen lines or so (to work to degree needed for 
      configs), wouldn't it make sense to add &quot;full support&quot; for YAML into 
      Jackson family of plug-ins?
    </p>
    <p>
      I thought it would.
    </p>
    <p>
      <b>2. And Then There Was One More Backend for Jackson</b>
    </p>
    <p>
      Turns out that implementation was, indeed, quite easy. I was able to 
      improve certain things -- for example, module can use lower level API to 
      keep performance bit better; and output side also works, not just reader 
      -- but in a way, there isn't all that much to do since all module has to 
      do is to convert YAML events into JSON events, and maybe help with some 
      conversions.
    </p>
    <p>
      Some of more advanced things include:
    </p>
    <ul>
      <li>
        Format auto-detection works, thanks to &quot;---&quot; document prefix (that 
        generator also produces by default)
      </li>
      <li>
        Although YAML itself exposes all scalars as text (unless type hints 
        are enabled, which adds more noise in content), module uses heuristics 
        to make parser implementation bit more natural; so although 
        data-binding can also coerce types, this should usually not be needed
      </li>
      <li>
        Configuration includes settings to change output style, to allow use 
        of more aesthetically pleasing output (for those who prefer &quot;wiki 
        look&quot;, for example)
      </li>
    </ul>
    <p>
      At this point, functionality has been tested with a broad if shallow set 
      of unit tests; but because data-binding used is 100% same as with JSON, 
      testing is actually sufficient to use module for some work.
    </p>
    <p>
      <b>3. Usage? So boring I tell you</b>
    </p>
    <p>
      Oh. And you might be interested in knowing how to use the module. This 
      is the boring part, since.... there isn't really much to it.
    </p>
    <p>
      You just use &quot;YAMLFactory&quot; wherever you would normally use 
      &quot;JsonFactory&quot;; and then under the hood you get &quot;YAMLParser&quot; and 
      &quot;YAMLGenerator&quot; instances, instead of JSON equivalents. And then you 
      either use parser/generator directly, or, more commonly, construct an 
      &quot;ObjectMapper&quot; with &quot;YAMLFactory&quot; like so (code snippet itself is from 
      test &quot;SimpleParseTest.java&quot;)
    </p>
    <hr>
    

    <pre>  ObjectMapper mapper = new ObjectMapper(new YAMLFactory());<br>  User user = mapper.readValue(&quot;firstName: Billy\n&quot;<br>    +&quot;lastName: Baggins\n&quot;<br>    +&quot;gender: MALE\n&quot;<br>    +&quot;userImage: AQIDBAY=&quot;,<br>   User.class);</pre>
    <p>
      <hr>
      and to get the functionality itself, Maven dependency is:<hr>
    </p>
    <pre>&lt;dependency&gt;
  &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt;
  &lt;artifactId&gt;jackson-dataformat-yaml&lt;/artifactId&gt;
  &lt;version&gt;2.0.0&lt;/version&gt;
&lt;/dependency&gt;</pre>
    <hr>
    

    <p>
      <b>4. That's all Folks -- until you give us some Feedback!</b>
    </p>
    <p>
      That's it for now. I hope some of you will try out this new backend, and 
      help us further make Jackson 2.0 the &quot;Universal Java Data Processor&quot;
    </p></p>
     <p class="entry-footer">
          <span class="post-footers">Posted by Tatu Saloranta  at Thursday, May 03, 2012 10:12 PM </span>
<br />     Categories: <a href="http://www.cowtowncoder.com/blog/archives/cat_java.html">Java</a>, <a href="http://www.cowtowncoder.com/blog/archives/cat_json.html">JSON</a>, <a href="http://www.cowtowncoder.com/blog/archives/cat_opensource.html">Open Source</a>
<br />
<span class="separator">|</span> <a class="permalink" href="http://www.cowtowncoder.com/blog/archives/2012/05/entry_474.html">Permalink</a>
<span class="separator">|</span><a href="http://www.cowtowncoder.com/blog/archives/2012/05/entry_474.html#disqus_thread">Comments</a>
<BlogItemBacklinksEnabled> | <a href="http://www.cowtowncoder.com/blog/archives/2012/05/entry_474.html#links">links to this post</a></BlogItemBacklinksEnabled> 

     </p>
          </div>
     </div>
</div>
   
     <h2 class="date-header">Tuesday, April 10, 2012 </h2>
<div class="entry" id="post-473">
     <h3 class="entry-header">What me like YAML? (Confessions of a JSON advocate)</h3>
     
     <div class="entry-content">
          <div class="entry-body">
               <p><p>
      Ok. I have to admit that I learnt something new and gained bit more 
      respect for YAML data format recently, when working on the 
      proof-of-concept for YAML-on-Jackson (<a href="https://github.com/FasterXML/jackson-dataformat-yaml">jackson-dataformat-yaml</a>; 
      more on this on yet another Jackson 2.0 article, soon).<br>And since it 
      would be intellectually dishonest not to mention that my formerly 
      negative view on YAML has brightened up a notch, here's my write-up on 
      this bit of enlightenment.
    </p>
    <p>
      <b>1. Bad First Impressions Stick</b>
    </p>
    <p>
      My first look at YAML via its definition basically made my stomach turn. 
      It just looked so much like a bad American Ice Cream: &quot;Too Much of 
      Everything&quot; -- hey, if it isn't enough to have chocolate, banana and 
      walnut, let's throw in bit of caramel, root beer essence and touch of 
      balsamic vinegar; along with bit of organic arugula to spice things 
      up!&quot;. That isn't the official motto, I thought, but might as well be. If 
      there is an O'Reilly book on YAML it surely must have platypus as the 
      cover animal.
    </p>
    <p>
      That was my thinking up until few weeks ago.
    </p>
    <p>
      <b>2. Tale of the Two Goals</b>
    </p>
    <p>
      I have read most of YAML specification (which is not badly written at 
      all) multiple times, as well as shorter descriptions. My overall 
      conclusion has always been that there are multiple high-level design 
      decisions that I disagree with, and that these can mostly be summarized 
      that it tries to do too many things, tries to solve multiple conflicting 
      use cases.
    </p>
    <p>
      But recently when working on adding YAML support as Jackson module 
      (based on nice <a href="http://code.google.com/p/snakeyaml/">SnakeYAML</a> 
      library, solid piece of code, very unlike most parsers/generators I have 
      seen), I realized that fundamentally there are just two conflicting 
      goals:
    </p>
    <ol>
      <li>
        Define a Wiki-style markup for data (assuming it is easier to not only 
        write prose in, but also data)
      </li>
      <li>
        Create a straight-forward Object serialization data format
      </li>
    </ol>
    <p>
      (it is worth noting that these goals are orthogonal, functionality-wise; 
      but they conflict at level of syntax, visual appearance and complicate 
      handling significantly, mostly because there is always &quot;more than one 
      way to do it&quot; (Perl motto!))
    </p>
    <p>
      I still think that one could solve the problem better by defining two, 
      not one, format: first one with a Wiki dialect; and second one with a 
      clean data format.<br>But this lead me to think about something: what if 
      those weird Wiki-style aspects were removed from YAML? Would I still 
      dislike the format?
    </p>
    <p>
      And I came to conclusion that no, I would not dislike it. In fact, I 
      might like it. A lot.
    </p>
    <p>
      Why? Let's see which things I like in YAML; things that JSON does not 
      have, but really really should have in the ideal world.
    </p>
    <p>
      <b>3. Things that YAML has and JSON should have</b>
    </p>
    <p>
      Here's the quick rundown:
    </p>
    <ol>
      <li>
        Comments: oh lord, what kind of textual data format does NOT have 
        comments? JSON is the only one I know of; and even it had them before 
        spec was finalized. I can only imagine a brain fart of colossal 
        proportions caused it to be removed from the spec...
      </li>
      <li>
        (optional) Document start and end markers (&quot;---&quot; header, &quot;...&quot; 
        footer&quot;). This is such a nice thing to have; both for format 
        auto-detection purpose as well as for framing for data feeds. It's bit 
        of a no-brainer; but suspiciously, JSON has nothing of sort (XML does 
        have XML declaration which _almost_ works well, but not quite; but I 
        digress)
      </li>
      <li>
        Type tags for type metadata: in YAML, one can add optional type tags, 
        to further indicate type of an Object (or any value actually). This is 
        such an essential thing to have; and with JSON one must use in-band 
        constructs that can conflict with data. XML at least has attributes 
        (&quot;xsi:type&quot;).
      </li>
      <li>
        Aliases/anchors for Object Identity (aka &quot;id / idref&quot;): although data 
        is data, not objects with identity, having means to optionally pass 
        identity information is very, very useful. And here too XML has some 
        support (having attributes for metadata is convenient); and JSON has 
        nada.
      </li>
    </ol>
    <p>
      The common theme with above is that all extra information is optional; 
      but if used, it is included discreetly and can be used as appropriate by 
      encoders, decoders, with or without using language- or platform-specific 
      resolution mechanisms.<br>And I think YAML actually declares these 
      things pretty well: it is neither over nor under engineered with respect 
      to these features. This is surprisingly delicate balance, and very well 
      chosen. I have seen over-complicated data formats (at Amazon, for 
      example) that didn't know where to stop; and we can see how JSON stopped 
      too short of even most rudimentary things (... comments). Interestingly, 
      XML almost sort-of has these features; but they come about with extra 
      constructs (xsi:type via XML Schema), or are side effects of otherwise 
      quirky features (element/attribute separation).
    </p>
    <p>
      Having had to implement equivalent functionality on top of simplistic 
      JSON construct (&quot;add yet another meta-property, in-line with actual 
      data; allow a way to configure it to reduce conflicts&quot;), I envy having 
      these constructs as first-level concepts, convenient little additions 
      that allow proper separation of data and metadata (type, object id; 
      comments).
    </p>
    <p>
      <b>4. Uses for YAML</b>
    </p>
    <p>
      Still, having solved/worked around all of above problems -- Jackson 1.5 
      added full support for polymorphic types (&quot;type tags&quot;); 2.0 finally 
      added Object Identity (&quot;alias/anchor&quot;), use of linefeeds for framing can 
      substitute for document boundaries -- I do not have compelling case for 
      using YAML for data transfer. It's almost a pity -- I have come to 
      realize that YAML could have been a great data format (it is also old 
      enough to have challenged popularity of JSON, both seem to have been 
      conceived at about same time). As is, it is almost one.
    </p>
    <p>
      Somewhat ironically, then, is that maybe Wiki features are acceptable 
      for the other main use case: that of configuration files. This is the 
      use case I have for YAML; and the main reason for writing compatibility 
      module (inspired by libs/frameworks like <a href="https://github.com/codahale/dropwizard">DropWizard</a> 
      which use YAML as the main config file format).
    </p></p>
     <p class="entry-footer">
          <span class="post-footers">Posted by Tatu Saloranta  at Tuesday, April 10, 2012 9:52 PM </span>
<br />     Categories: <a href="http://www.cowtowncoder.com/blog/archives/cat_json.html">JSON</a>
<br />
<span class="separator">|</span> <a class="permalink" href="http://www.cowtowncoder.com/blog/archives/2012/04/entry_473.html">Permalink</a>
<span class="separator">|</span><a href="http://www.cowtowncoder.com/blog/archives/2012/04/entry_473.html#disqus_thread">Comments</a>
<BlogItemBacklinksEnabled> | <a href="http://www.cowtowncoder.com/blog/archives/2012/04/entry_473.html#links">links to this post</a></BlogItemBacklinksEnabled> 

     </p>
          </div>
     </div>
</div>
   
     <h2 class="date-header">Friday, April 06, 2012 </h2>
<div class="entry" id="post-470">
     <h3 class="entry-header">Take your JSON processing to Mach 3 with Jackson 2.0, Afterburner</h3>
     
     <div class="entry-content">
          <div class="entry-body">
               <p><p>
      (this is part on-going &quot;Jackson 2.0&quot; series, starting with &quot;<a href="/blog/archives/2012/03/entry_466.html">Jackson 
      2.0 released</a>&quot;)
    </p>
    <p>
      <b>1. Performance overhead of databinding</b>
    </p>
    <p>
      When using automatic data-binding Jackson offers, there is some amount 
      of overhead compared to manually writing equivalent code that would use 
      Jackson streaming/incremental parser and generator. But how overhead is 
      there? The answer depends on multiple factors, including exactly how 
      good is your hand-written code (there are a few non-obvious ways to 
      optimize things, compared to data-binding where there is little 
      configurability wrt performance).
    </p>
    <p>
      But looking at benchmarks such as <a href="https://github.com/eishay/jvm-serializers/wiki">jvm-serializers</a>, 
      one could estimate that it may take anywhere between 35% and 50% more 
      time to serialize and deserialize POJOs, compared to highly tuned 
      hand-written alternative. This is usually not enough to matter a lot, 
      considering that JSON processing overhead is typically only a small 
      portion of all processing done.
    </p>
    <p>
      <b>2. Where does overhead come?</b>
    </p>
    <p>
      There are multiple things that automatic data-binding has to do that 
      hand-written alternatives do not. But at high level, there are really 
      two main areas:
    </p>
    <ol>
      <li>
        Configurability to produce/consume alternative representations; code 
        that has to support multiple ways of doing things can not be as 
        aggressively optimized by JVM and may need to keep more state around.
      </li>
      <li>
        Data access to POJOs is done dynamically using Reflection, instead of 
        directly accessing field values or calling setters/getters
      </li>
    </ol>
    <p>
      While there isn't much that can be done for former, in general sense 
      (especially since configurability and convenience are major reasons for 
      popularity of data-binding), latter overhead is something that could be 
      theoretically eliminated.
    </p>
    <p>
      How? By generating bytecode that does direct access to fields and calls 
      to getters/setters (as well as for constructing new instances).
    </p>
    <p>
      <b>3. Project Afterburner</b>
    </p>
    <p>
      And this is where <a href="https://github.com/FasterXML/jackson-module-afterburner">Project 
      Afterburner</a> comes in. What it does really is as simple as generating 
      byte code, dynamically, to mostly eliminate Reflection overhead. 
      Implementation uses well-known lightweight bytecode library called <a href="http://asm.ow2.org/">ASM</a>.
    </p>
    <p>
      Byte code is generated to:
    </p>
    <ol>
      <li>
        Replace &quot;Class.newInstance()&quot; calls with equivalent call to 
        zero-argument constructor (currently same is not done for 
        multi-argument Creator methods)
      </li>
      <li>
        Replace Reflection-based field access (Field.set() / Field.get()) with 
        equivalent field dereferencing
      </li>
      <li>
        Replace Reflection-based method calls (Method.invoke(...)) with 
        equivalent direct calls
      </li>
      <li>
        For small subset of simple types (int, long, String, boolean), further 
        streamline handling of serializers/deserializers to avoid auto-boxing
      </li>
    </ol>
    <p>
      It is worth noting that there are certain limitations to access: for 
      example, unlike with Reflection, it is not possible to avoid visibility 
      checks; which means that access to private fields and methods must still 
      be done using Reflection.
    </p>
    <p>
      <b>4. Engage the Afterburner!</b>
    </p>
    <p>
      Using Afterburner is about as easy as it can be: you just create and 
      register a module, and then use databinding as usual:
    </p>
    <hr>
    

    <pre>Object mapper = new ObjectMapper()
mapper.registerModule(new AfterburnerModule());<br>String json = mapper.writeValueAsString(value);<br>Value value = mapper.readValue(json, Value.class);<br></pre>
    <div>
      <hr>
      absolutely nothing special there (note: for Maven dependency, downloads, 
      go see the <a href="https://github.com/FasterXML/jackson-module-afterburner">project 
      page</a>).
    </div>
    <p>
      <b>5. How much faster?</b>
    </p>
    <p>
      Earlier I mentioned that Reflection is just one of overhead areas. In 
      addition to general complexity from configurability, there are cases 
      where general data-binding has to be done using simple loops, whereas 
      manual code could use linear constructs. Given this, how much overhead 
      remains after enabling Afterburner?
    </p>
    <p>
      As per jvm-serializers, more than 50% of speed difference between 
      data-binding and manual variant are eliminated. That is, data-bind with 
      afterburner is closer to manual variant than &quot;vanilla&quot; data-binding. 
      There is still something like 20-25% additional time spent, compared to 
      highest optimized cases; but results are definitely closer to optimal.
    </p>
    <p>
      Given that all you really have to do is to just add the module, register 
      it, and see what happens, it just might make sense to take Afterburner 
      for a test ride.
    </p>
    <p>
      <b>6. Disclaimer</b>
    </p>
    <p>
      While Afterburner has been used by a few Jackson users, it is still not 
      very widely used -- after all, while it has been available since 1.8, in 
      some form, it has not been advertised to users. This article can be 
      considered an announcement of sort.
    </p>
    <p>
      Because of this, there may be rought edges; and if you are unlucky you 
      might find one of two possible problems:
    </p>
    <ul>
      <li>
        Get no performance improvement (which is likely due to Afterburner not 
        covering some specific code path(s)), or
      </li>
      <li>
        Get a bytecode verification problem when a serializer/deserializer is 
        being loaded
      </li>
    </ul>
    <p>
      latter case obviously being nastier. But on plus side, this should be 
      obvious right away (and NOT after running for an hour); nor should there 
      be a way for it to cause data losses or corruption; JVMs are rather good 
      at verifying bytecode upon trying to load it.
    </p>
    <p>
      
    </p></p>
     <p class="entry-footer">
          <span class="post-footers">Posted by Tatu Saloranta  at Friday, April 06, 2012 7:24 PM </span>
<br />     Categories: <a href="http://www.cowtowncoder.com/blog/archives/cat_java.html">Java</a>, <a href="http://www.cowtowncoder.com/blog/archives/cat_json.html">JSON</a>, <a href="http://www.cowtowncoder.com/blog/archives/cat_performance.html">Performance</a>
<br />
<span class="separator">|</span> <a class="permalink" href="http://www.cowtowncoder.com/blog/archives/2012/04/entry_470.html">Permalink</a>
<span class="separator">|</span><a href="http://www.cowtowncoder.com/blog/archives/2012/04/entry_470.html#disqus_thread">Comments</a>
<BlogItemBacklinksEnabled> | <a href="http://www.cowtowncoder.com/blog/archives/2012/04/entry_470.html#links">links to this post</a></BlogItemBacklinksEnabled> 

     </p>
          </div>
     </div>
</div>
   
     <h2 class="date-header"> </h2>
<div class="entry" id="post-469">
     <h3 class="entry-header">Notes on upgrading Jackson from 1.9 to 2.0</h3>
     
     <div class="entry-content">
          <div class="entry-body">
               <p><p>
      If you have existing code that uses Jackson version 1.x, and you would 
      like to see how to upgrade to 2.0, there isn't much documentation around 
      yet; although <a href="http://wiki.fasterxml.com/JacksonRelease20">Jackson 
      2.0 release</a> page does outline all the major changes that were made.
    </p>
    <p>
      So let's try to see what kind of steps are typically needed (note: this 
      is based on Jackson 2.0 upgrade experiences by <a href="https://twitter.com/#!/pamonrails">@pamonrails</a> 
      -- thanks Pierre!)
    </p>
    <p>
      <b>0. Pre-requisite: start with 1.9</b>
    </p>
    <p>
      At this point, I assume code to upgrade works with Jackson 1.9, and does 
      not use any deprecated interfaces (many methods and some classes were 
      deprecated during course of 1.x; all deprecated things went away with 
      2.0). So if your code is using an older 1.x version, the first step is 
      usually to upgrade to 1.9, as this simplifies later steps.
    </p>
    <p>
      <b>1. Update Maven / JAR dependencies</b>
    </p>
    <p>
      The first thing to do is to upgrade jars. Depending on your build 
      system, you can either get jars from <a href="http://wiki.fasterxml.com/JacksonDownload">Jackson 
      Download</a> page, or update Maven dependencies. New Maven dependencies 
      are:
    </p>
    <pre>
&lt;dependency&gt;
  &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
  &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;
  &lt;version&gt;2.0.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
  &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;
  &lt;version&gt;2.0.0&lt;/version&gt;
&lt;/dependency&gt;<br>&lt;dependency&gt;
  &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
  &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
  &lt;version&gt;2.0.0&lt;/version&gt;
&lt;/dependency&gt;</pre>
    <p>
      The main thing to note is that instead of 2 jars (&quot;core&quot;, &quot;mapper&quot;), 
      there are now 3: former core has been split into separate &quot;annotations&quot; 
      package and remaining &quot;core&quot;; latter contains streaming/incremental 
      parser/generator components. And &quot;databind&quot; is a direct replacement of 
      &quot;mapper&quot; jar.
    </p>
    <p>
      Similarly, you will need to update dependencies to supporting jars like:
    </p>
    <ul>
      <li>
        Mr Bean: com.fasterxml.jackson.module / jackson-module-mrbean
      </li>
      <li>
        Smile binary JSON format: com.fasterxml.jackson.dataformat / 
        jackson-dataformat-smile
      </li>
      <li>
        JAX-RS JSON provider: com.fasterxml.jackson.jaxrs / 
        jackson-jaxrs-json-provider
      </li>
      <li>
        JAXB annotation support (&quot;xc&quot;): com.fasterxml.jackson.module / 
        jackson-module-jaxb-annotations
      </li>
    </ul>
    <p>
      these, and many many more extension modules have their own project pages 
      under <a href="https://github.com/FasterXML/">FasterXML Git repo</a>.
    </p>
    <p>
      <b>2. Import statements</b>
    </p>
    <p>
      Since Jackson 2.0 code lives in Java packages, you will need to change 
      import statements. Although most changes are mechanical, there isn't 
      strict set of mappings.
    </p>
    <p>
      The way I have done this is to simply use an IDE like Eclipse, and 
      remove all invalid import statements; and then use Eclipse functionality 
      to find new packages. Typical import changes include:
    </p>
    <ul>
      <li>
        Core types: org.codehaus.jackson.JsonFactory/JsonParser/JsonGenerator 
        -&gt; com.fasterxml.jackson.core.JsonFactory/JsonParser/JsonGenerator
      </li>
      <li>
        Databind types: org.codehaus.jackson.map.ObjectMapper -&gt; 
        com.fasterxml.jackson.databind.ObjectMapper
      </li>
      <li>
        Standard annotations: org.codehaus.jackson.annotate.JsonProperty -&gt; 
        com.fasterxml.jackson.annotation.JsonProperty
      </li>
    </ul>
    <p>
      It is often convenient to just use wildcards imports for main categories 
      (com.fasterxml.jackson.core.*, com.fasterxml.jackson.databind.*, 
      com.fasterxml.jackson.annotation.*)
    </p>
    <p>
      <b>3. SerializationConfig.Feature, DeserializationConfig.Feature</b>
    </p>
    <p>
      The next biggest change was that of refactoring on/off Features, 
      formerly defined as inner Enums of SerializationConfig and 
      DeserializationConfig classes. For 2.0, enums were moved to separate 
      stand-alone enums:
    </p>
    <ol>
      <li>
        <i>DeserializationFeature</i> contains most of entries from former 
        DeserializationConfig.Feature
      </li>
      <li>
        <i>SerializationFeature</i> contains most of entries from former 
        SerializationConfig.Feature
      </li>
    </ol>
    <p>
      Entries that were NOT moved along are ones that were shared by both, and 
      instead were added into new <i>MapperFeature</i> enumeration, for 
      example:
    </p>
    <ul>
      <li>
        SerializationConfig.Feature.DEFAULT_VIEW_INCLUSION became 
        MapperFeature.DEFAULT_VIEW_INCLUSION
      </li>
    </ul>
    <p>
      <b>4. Tree model method name changes (JsonNode)</b>
    </p>
    <p>
      Although many methods (and some classes) were renamed here and there, 
      mostly these were one-offs. But one area where major naming changes were 
      done was with Tree Model -- this because 1.x names were found to be 
      rather unwieldy and unnecessarily verbose. So we decided that it would 
      make sense to try to do a &quot;big bang&quot; name change with 2.0, to get to a 
      clean(er) baseline.
    </p>
    <p>
      Changes made were mostly of following types:
    </p>
    <ul>
      <li>
        <i>getXxxValue</i>() changes to <i>xxValue</i>(): getTextValue() -&gt; 
        textValue(), getFieldNames() -&gt; fieldNames() and so on.
      </li>
      <li>
        getXxxAsYyy() changes to asYyy(): getValueAsText() -&gt; asText()<b>
</b>      </li>
    </ul>
    <p>
      <b>5. Miscellaneous</b>
    </p>
    <p>
      Some classes were removed:
    </p>
    <ul>
      <li>
        CustomSerializerFactory, CustomDeserializerFactory: should instead use 
        Module (like SimpleModule) for adding custom serializers, deserializers
      </li>
    </ul>
    <p>
      <b>6. What else?</b>
    </p>
    <p>
      This is definitely an incomplete list. Please let me know what I missed, 
      when you try upgrading!
    </p></p>
     <p class="entry-footer">
          <span class="post-footers">Posted by Tatu Saloranta  at Friday, April 06, 2012 9:33 AM </span>
<br />     Categories: <a href="http://www.cowtowncoder.com/blog/archives/cat_java.html">Java</a>, <a href="http://www.cowtowncoder.com/blog/archives/cat_json.html">JSON</a>, <a href="http://www.cowtowncoder.com/blog/archives/cat_opensource.html">Open Source</a>
<br />
<span class="separator">|</span> <a class="permalink" href="http://www.cowtowncoder.com/blog/archives/2012/04/entry_469.html">Permalink</a>
<span class="separator">|</span><a href="http://www.cowtowncoder.com/blog/archives/2012/04/entry_469.html#disqus_thread">Comments</a>
<BlogItemBacklinksEnabled> | <a href="http://www.cowtowncoder.com/blog/archives/2012/04/entry_469.html#links">links to this post</a></BlogItemBacklinksEnabled> 

     </p>
          </div>
     </div>
</div>
   
     <h2 class="date-header">Tuesday, March 27, 2012 </h2>
<div class="entry" id="post-467">
     <h3 class="entry-header">Jackson 2.0: now with XML, too!</h3>
     
     <div class="entry-content">
          <div class="entry-body">
               <p><p>
      (note: for general information on Jackson 2.0.0, see the previous 
      article, &quot;<a href="http://www.cowtowncoder.com/blog/archives/2012/03/entry_466.html">Jackson 
      2.0.0 released</a>&quot;)
    </p>
    <p>
      While Jackson is most well-known as a JSON processor, its data-binding 
      functionality is not tied to JSON format.<br>Because of this, there have 
      been developments to extend support for XML and related things with 
      Jackson; and in fact support for using JAXB (Java Api for Xml Binding) 
      annotations has been included as an optional add-on since earliest 
      official Jackson versions.
    </p>
    <p>
      But Jackson 2.0.0 significantly increases the scope of XML-related 
      functionality.
    </p>
    <p>
      <b>1. Improvements to JAXB annotation support</b>
    </p>
    <p>
      Optional support for using JAXB annotations (package 'javax.xml.bind' in 
      JDK) became its own <a href="https://github.com/FasterXML/jackson-module-jaxb-annotations">Github 
      project</a> with 2.0.<br>
    </p>
    <p>
      Functionality is provided by <i>com.fasterxml.jackson.databind.AnnotationIntrospector</i> 
      implementation '<b>c<i>om.fasterxml.jackson.module.jaxb.JaxbAnnotationIntrospector</i></b>', 
      which can be used in addition to (or instead of) the standard 
      'com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector'.
    </p>
    <p>
      But beyond becoming main-level project of its own, 2.0 adds to already 
      extensive support for JAXB annotations by:
    </p>
    <ul>
      <li>
        Making <i>@XmlJavaTypeAdapter</i> work for Lists and Maps
      </li>
      <li>
        Adding support for <b><i>@XmlID</i></b> and <b><i>@XmlIDREF</i></b> -- 
        this was possible due to addition of Object Identity feature in core 
        Jackson databind -- which basically means that Object Graphs (even 
        cyclic ones) can be supported even if only using JAXB annotations.
      </li>
    </ul>
    <p>
      the second feature (@XmlID, @XmlIDREF) has been the number one request 
      for JAXB annotation support, and we are happy that it now works.<br>Canonical 
      example of using this feature would be:
    </p>
    <hr>
    

    <pre>    @XmlAccessorType(XmlAccessType.FIELD)
    public class Employee<br>    {
        @XmlAttribute
        @XmlID
        protected String id;
     
        @XmlAttribute
        protected String name;
     
        @XmlIDREF
        protected Employee manager;
     
        @XmlElement(name=&quot;report&quot;)
        @XmlIDREF
        protected List&lt;Employee&gt; reports;
     
        public Employee() {
            reports = new ArrayList&lt;Employee&gt;();
        }
    }</pre>
    <hr>
    

    <p>
      where entries would be serialized such that the first reference to an 
      Employee is serialized fully, and later references use value of 'id' 
      field; conversely, when reading XML back, references get re-created 
      using id values.
    </p>
    <p>
      <b>2. XML databinding</b>
    </p>
    <p>
      Support for JAXB annotations may be useful when there is need to provide 
      both JSON and XML representations of data. But to actually produce XML, 
      you need to use something like JAXB or XStream.
    </p>
    <p>
      Or do you?
    </p>
    <p>
      One of experimental new projects that Jackson project started a while 
      ago was something called &quot;jackson-xml-databind&quot;.<br>After 
      being developed for a while along with Jackson 1.8 and 1.9, it 
      eventually morphed into project &quot;<a href="https://github.com/FasterXML/jackson-dataformat-xml">jackson-dataformat-xml</a>&quot;, 
      hosted at Github.
    </p>
    <p>
      With 2.0.0 we have further improved functionality, added tests; and also 
      worked with developers who have actually used this for production 
      systems.<br>This means that the module is now considered full supported 
      and no longer an experimental add-on.
    </p>
    <p>
      So let's have a look at how to use XML databinding.
    </p>
    <p>
      The very first thing is to create the mapper object. Here we must use a 
      specific sub-class, XmlMapper
    </p>
    <pre>  XmlMapper xmlMapper = new XmlMapper();<br>  // internally will use an XmlFactory for parsers, generators</pre>
    <p>
      (note: this step differs from some other data formats, like Smile, which 
      only require use of custom JsonFactory sub-class, and can work with 
      default ObjectMapper -- XML is bit trickier to support and thus we need 
      to override some aspects of ObjectMapper)
    </p>
    <p>
      With a mapper at hand, we can do serialization like so:
    </p>
    <hr>
    

    <pre>  public enum Gender { MALE, FEMALE };
  public class User {
    public Gender gender;
    public String name;
    public boolean verified;
    public byte[] image;
  }

  User user = new User(); // and configure
  String xml = xmlMapper.writeValueAsString(user);</pre>
    <hr>
    and get XML like:<hr>

    <pre>  &lt;User&gt;<br>    &lt;gender&gt;MALE&lt;/gender&gt;<br>    &lt;name&gt;Bob&lt;/name&gt;<br>    &lt;verified&gt;true&lt;/verified&gt;<br>    &lt;image&gt;BARWJRRWRIWRKF01FK=&lt;/image&gt;<br>  &lt;/User&gt;</pre>
    <p>
      which we could read back as a POJO:
    </p>
    <pre>  User userResult = xmlMapper.readValue(xml, User.class);</pre>
    <p>
      But beyond basics, we can obviously use annotations for customizing some 
      aspects, like element/attribute distinction, use of namespaces:
    </p>
    <hr>
    

    <pre>  JacksonXmlRootElement(&quot;custUser&quot;)<br>  public class CustomUser {
    @JacksonXmlProperty(namespace=&quot;http://test&quot;)
    public Gender gender;<br>    @JacksonXmlProperty(localname=&quot;myName&quot;)
    public String name;

    @JacksonXmlProperty(isAttribute=true)  
    public boolean verified;
    public byte[] image;
  }
  
  // gives XML like:<br>  &lt;custUser verified=&quot;true&quot;&gt;<br>     &lt;ns:gender xmlns:ns=&quot;http://test&quot;&gt;MALE&lt;/gender&gt;<br>     &lt;myName&gt;Bob&lt;/myName&gt;<br>     &lt;image&gt;BARWJRRWRIWRKF01FK=&lt;/image&gt;<br>   &lt;/custUser&gt;</pre>
    <hr>
    

    <p>
      Apart from this, all standard Jackson databinding features should work: 
      polymorphic type handling, object identity for full object graphs (new 
      with 2.0); even value conversions and base64 encoding!
    </p>
    <p>
      <b>3. Jackson-based XML serialization for JAX-RS (&quot;move over JAXB!&quot;)</b>
    </p>
    <p>
      So far so good: we can produce and consume XML using powerful Jackson 
      databinding. But the latest platform-level improvement in Java lang is 
      the use of JAX-RS implementations like Jersey. Wouldn't it be nice to 
      make Jersey use Jackson for both JSON <b>and</b> XML? That would remove 
      one previously necessary add-on library (like JAXB).
    </p>
    <p>
      We think so too, which is why we created &quot;<a href="https://github.com/FasterXML/jackson-jaxrs-xml-provider">jackson-jaxrs-xml-provider</a>&quot; 
      project, which is the sibling of existing &quot;<a href="https://github.com/FasterXML/jackson-jaxrs-json-provider">jackson-jaxrs-json-provider</a>&quot; 
      project.<br>As with the older JSON provider, by registering this 
      provider you will get automatic data-binding to and from XML, using 
      Jackson XML data handler explained in the previous section.
    </p>
    <p>
      It is of course worth noting that Jersey (and RESTeasy, CXF) already 
      provide XML databinding using other libraries (usually JAXB), so use of 
      this provider is optional.<br>So why advocate use of Jackson-based 
      variant? One benefits is good performance -- a bit better than JAXB, and 
      much faster than XStream, as per <a href="https://github.com/eishay/jvm-serializers">jvm-serializer</a> 
      benchmark (performance is limited by the underlying XML Stax processor 
      -- but Aalto is wicked fast, not much slower than Jackson).<br>But more 
      important is simplification of configuration and code: it is all 
      Jackson, so annotations can be shared, and all data-binding power can be 
      used for both representations.<br>
    </p>
    <p>
      It is most likely that you find this provider useful if the focus has 
      been on producing/consuming JSON, and XML is being added as a secondary 
      addition. If so, this extension is a natural fit.
    </p>
    <p>
      <b>4. Caveat Emptor</b>
    </p>
    <p>
      <b>4.1 Asymmetric: &quot;POJO first&quot;</b>
    </p>
    <p>
      It is worth noting that the main supported use case is that of starting 
      with Java Objects, serializing them as XML, and reading such 
      serialization back as Objects.<br>And the explicit goal is that ideally 
      all POJOs that can be serialized as JSON should also be serializable 
      (and deserializable back into same Objects) as XML.<br>
    </p>
    <p>
      But there is no guarantee that any given XML can be mapped to a Java 
      Object: some can be, but not all.
    </p>
    <p>
      This is mostly due to complexity of XML, and its inherent 
      incompatibility with Object models (&quot;Object/XML impedance mismatch&quot;): 
      for example, there is no counterpart to XML mixed content in Object 
      world. Arbitrary sequences of XML elements are not necessarily 
      supported; and in some cases explicit nesting must be used (as is the 
      case with Lists, arrays).
    </p>
    <p>
      This means that if you do start with XML, you need to be prepared for 
      possibility that some changes are needed to format, or you need 
      additional steps for deserialization to clean up or transform structures.
    </p>
    <p>
      <b>4.2 No XML Schema support, mixed content</b>
    </p>
    <p>
      Jackson XML functionality specifically has zero support for XML Schema. 
      Although we may work in this area, and perhaps help in using XML Schemas 
      for some tasks, your best bet currently is to use tools like XJC from 
      JAXB project: it can generate POJOs from XML Schema.
    </p>
    <p>
      Mixed content is also out of scope, explicitly. There is no natural 
      representation for it; and it seems pointless to try to fall back to 
      XML-specific representations (like DOM trees). If you need support for 
      &quot;XMLisms&quot;, you need to look for XML-centric tools.
    </p>
    <p>
      <b>4.3 Some root values problematic: Map, List</b>
    </p>
    <p>
      Although we try to support all Java Object types, there are some 
      unresolved issues with &quot;root values&quot;, values that are not referenced via 
      POJO properties but are the starting point of 
      serialization/deserialization. Maps are especially tricky, and we 
      recommend that when using Maps and Lists, you use a wrapper root object, 
      which then references Map(s) and/or List(s).
    </p>
    <p>
      (it is worth noting that JAXB, too, has issues with Map handling in 
      general: XML and Maps do not mesh particularly well, unlike JSON and 
      Maps).
    </p>
    <p>
      <b>4.4 JsonNode not as useful as with JSON</b>
    </p>
    <p>
      Finally, Jackson Tree Model, as expressed by JsonNodes, does not 
      necessarily work well with XML either. Problem here is partially general 
      challenges of dealing with Maps (see above); but there is the additional 
      problem that whereas POJO-based data binder can hide some of 
      work-arounds, this is not the case with JsonNode.
    </p>
    <p>
      So: you can deserialize all kinds of XML as JsonNodes; and you can 
      serialize all kinds of JsonNodes as XML, but round-tripping might not 
      work. If tree model is your thing, you may be better off using 
      XML-specific tree models such as XOM, DOM4J, JDOM or plain old DOM.
    </p>
    <p>
      <b>5. Come and help us make it Even Better!</b>
    </p>
    <p>
      At this point we believe that Jackson provides a nice alternative for 
      existing XML producing/consuming toolkits. But what will really make it 
      the first-class package is Your Help -- with increased usage we can 
      improve quality and further extend usability, ergonomics and design.
    </p>
    <p>
      So if you are at all interested in dealing with XML, consider trying out 
      Jackson XML functionality!
    </p></p>
     <p class="entry-footer">
          <span class="post-footers">Posted by Tatu Saloranta  at Tuesday, March 27, 2012 9:53 PM </span>
<br />     Categories: <a href="http://www.cowtowncoder.com/blog/archives/cat_java.html">Java</a>, <a href="http://www.cowtowncoder.com/blog/archives/cat_json.html">JSON</a>, <a href="http://www.cowtowncoder.com/blog/archives/cat_xmlstax.html">XML/Stax</a>
<br />
<span class="separator">|</span> <a class="permalink" href="http://www.cowtowncoder.com/blog/archives/2012/03/entry_467.html">Permalink</a>
<span class="separator">|</span><a href="http://www.cowtowncoder.com/blog/archives/2012/03/entry_467.html#disqus_thread">Comments</a>
<BlogItemBacklinksEnabled> | <a href="http://www.cowtowncoder.com/blog/archives/2012/03/entry_467.html#links">links to this post</a></BlogItemBacklinksEnabled> 

     </p>
          </div>
     </div>
</div>
   
     <h2 class="date-header">Monday, March 26, 2012 </h2>
<div class="entry" id="post-466">
     <h3 class="entry-header">Jackson 2.0.0 released: going GitHub, handling cyclic graphs, builder style...</h3>
     
     <div class="entry-content">
          <div class="entry-body">
               <p><p>
      After furious weeks of coding and testing, the first major version of 
      upgrade of Jackson is here: 2.0 was just released, and available (from <a href="http://wiki.fasterxml.com/JacksonDownload">Download</a> 
      page, for example)
    </p>
    <p>
      <b>1. Major Upgrade? </b>
    </p>
    <p>
      So how does this upgrade differ from &quot;minor&quot; upgrades (like, from 1.8 to 
      1.9)? Difference is not based on amount of new functionality introduced 
      -- most Jackson 'minor' releases have contained as much new stuff as 
      major releases of other projects -- although 2.0 does indeed pack up 
      lots of goodies.
    </p>
    <p>
      Rather, major version bump indicates that code that uses Jackson 1.x is 
      neither backwards nor forwards compatible with Jackson 2.0.<br>That is, 
      you can not just replace 1.9 jars with 2.0 and hope that things work. 
      They will not.
    </p>
    <p>
      Why not? 2.0 code differs from 1.x with respect to packaging, such that:
    </p>
    <ol>
      <li>
        Java package used is &quot;com.fasterxml.jackson&quot; (instead of 
        &quot;org.codehaus.jackson&quot;)
      </li>
      <li>
        Maven group ids begin with &quot;com.fasterxml.jackson&quot; (instead of 
        &quot;org.codehaus.jackson&quot;)
      </li>
      <li>
        Maven artifact ids have change a bit too (core has been split into 
        &quot;core&quot; and &quot;annotations&quot;, for example)
      </li>
    </ol>
    <p>
      These are actually not big changes in and of itself: you just need to 
      change Maven dependencies, and for Java package, change import 
      statements. While some amount of work, these are mechanical changes. But 
      it does mean that upgrade is not basic plug-n-play operation.
    </p>
    <p>
      In addition, some classes have moved within package hierarchy, to better 
      align functional areas. Some have been refactored or carved (most 
      notably, <b>SerializationConfig.Feature</b> is now simply <b><i>SerializationFeature</i></b>, 
      and <b>DeserializationConfig.Feature </b>is now <b><i>DeserializationFeature</i></b>). 
      Most cases of types moving should be easy to solve with IDEs, but we 
      will also try to collect some sort of upgrade guide.
    </p>
    <p>
      For more details on packaging changes, check out &quot;<a href="wiki.fasterxml.com/JacksonRelease20">Jackson 
      2.0 release notes</a>&quot; page.
    </p>
    <p>
      <b>1.1 Why changes to package names?</b>
    </p>
    <p>
      The reason for choosing to move to new packages is to allow both Jackson 
      1.x and Jackson 2.x versions to be used concurrently. While smaller 
      projects will find it easier to just convert wholesale, many bigger 
      systems and (especially) frameworks will find ability to do incremental 
      upgrades useful. Without repackaging one would have to upgrade in 
      &quot;all-or-nothing&quot; way. But with repackaging this can be avoided, and 
      existing functionality converted gradually (within some limits; 
      transitive dependencies may still be problematic).
    </p>
    <p>
      <b>2. But wait! It is totally worth it!</b>
    </p>
    <p>
      I started with the &quot;bad news&quot; first, to get that out of the way, since 
      there is lots to like about the new version.<br>I will write more 
      detailed articles on specific features later on, but let's start with a 
      brief overview.
    </p>
    <p>
      <b>2.1 Community improvements: Better collaboration with GitHub</b>
    </p>
    <p>
      First big change is that Jackson project as a whole has moved to <a href="https://github.com/FasterXML">Github</a>. 
      While many extension projects (modules) had already started there, now 
      all core components have moved as well:
    </p>
    <ul>
      <li>
        <a href="https://github.com/FasterXML/jackson-core">Core streaming</a> 
        components (JsonParser, JsonGenerator)
      </li>
      <li>
        <a href="https://github.com/FasterXML/jackson-annotations">Core 
        Annotations</a>
      </li>
      <li>
        <a href="https://github.com/FasterXML/jackson-databind">Databinding</a> 
        (POJO databinding, tree model)
      </li>
    </ul>
    <p>
      as well as standard extension components such as:
    </p>
    <ul>
      <li>
        <a href="https://github.com/FasterXML/jackson-dataformat-smile">Smile 
        data format</a> (and <a href="https://github.com/FasterXML/jackson-dataformat-xml">XML</a>, 
        <a href="https://github.com/FasterXML/jackson-dataformat-csv">CSV</a>!)
      </li>
      <li>
        <a href="https://github.com/FasterXML/jackson-module-mrbean">Mr Bean</a> 
        module (POJO class generation from interfaces, abstract classes)
      </li>
      <li>
        <a href="https://github.com/FasterXML/jackson-module-jaxb-annotations">JAXB 
        annotation support</a>
      </li>
    </ul>
    <p>
      and many, many more (total project count is 17!)
    </p>
    <p>
      This should help make it much easier to contribute to projects; as well 
      as make it easier for packages to evolve at appropriate pace: there is 
      less need to synchronize &quot;big&quot; releases outside of 3 core packages, and 
      it is much easier to give scoped access to new contributors.
    </p>
    <p>
      <b>2.2 Feature: Handle Any Object Graphs, even Cyclic ones!</b>
    </p>
    <p>
      One of biggest so far unsupported use case been ability to handle 
      serialization and deserialization of cyclic graphs, and elimination of 
      duplicates due to shared references. Although existing <i>@JsonManagedReference</i> 
      annotation works for some cases (esp. many ORM-induced parent/child 
      cases), there has been no general solution.
    </p>
    <p>
      But now there is. Jackson 2.0 adds support for concept called &quot;<a href="http://wiki.fasterxml.com/JacksonFeatureObjectIdentity">Object 
      Identity</a>&quot;:ability to serialize Object Id for values, use this id for 
      secondary references; and ability to resolve these references when 
      deserializing). This feature has many similarities to &quot;Polymorphic Type 
      information&quot; handling which was introduced in Jackson 1.5.
    </p>
    <p>
      Although full explanation of how things work deserves its own article, 
      the basic idea is simple: you will need to annotate classes with new 
      annotation <b>@JsonIdentityInfo</b> (or, use it for properties that 
      reference type for which to add support), similar to how @JsonTypeInfo 
      is used for including type id:
    </p>
    <hr>
    

    <pre>  @JsonIdentityInfo(generator=ObjectIdGenerators.IntSequenceGenerator.class, property=&quot;@id&quot;)
  public class Identifiable {
    public int value;

    public Identifiable next;
  }</pre>
    <p>
      and with such definition, you could serialize following cyclic two-node 
      graph:
    </p>
    <pre><br>


  Identifiable ob1 = new Identifiable();
  ob1.value = 13;
  Identifiable ob2 = new Identifiable();
  ob2.value = 42;
  // link as a cycle:
  ob1.next = ob2;
  ob2.next = ob1;

  // and serialize!
  String json = objectMapper.writeValueAsString(ob1);</pre>
    <p>
      to get JSON like:
    </p>
    <pre>  {
   &quot;@id&quot; : 1,
   &quot;value&quot; : 13,
   &quot;next&quot; : {
    &quot;@id&quot; : 2,
    &quot;value&quot; : 42,
    &quot;next&quot; : 1
   }
  }</pre>
    <p>
      and obvious deserialize it back with:
    </p>
    <pre>  Identifiable result = objectMapper.readValue(json, Identifiable.class);</pre>
    <p>
      assertSame(ob1.next.next, ob1);
    </p>
    <p>
      Most details (such as id generation algorithm used, property use for 
      inclusions etc) are configurable; more on this on a later article.<br>Until 
      then, <a href="https://github.com/FasterXML/jackson-annotations/wiki/Documentation">Javadocs</a> 
      should help.
    </p>
    <p>
      <b>2.3 Feature: Support &quot;Builder&quot; style of POJO construction</b>
    </p>
    <p>
      Another highly-requested feature has been ability to support POJOs 
      created using &quot;Builder&quot; style. This means that POJOs are created using a 
      separate Builder object which has methods for changing property values; 
      and a &quot;build&quot; method that will create actual immutable POJO instance. 
      For example, considering following hypothetical Builder class:
    </p>
    <hr>
    

    <pre> public class ValueBuilder {
  private int x, y;

  // can use @JsonCreator to use non-default ctor, inject values etc
  public ValueBuilder() { }

  // if name is &quot;withXxx&quot;, works as is: otherwise use @JsonProperty(&quot;x&quot;) or @JsonSetter(&quot;x&quot;)!
  public ValueBuilder withX(int x) {
    this.x = x;
    return this; // or, construct new instance, return that
  }
  public ValueBuilder withY(int y) {
    this.y = y;
    return this;
  }
  public Value build() {
    return new Value(x, y);
  }
}</pre>
    <p>
      and value class it creates:
    </p>
    <pre>@JsonDeserialize(builder=ValueBuilder.class) // important!
public class Value {
  private final int x, y;
  protected Value(int x, int y) {
    this.x = x;
    this.y = y;
  }
}</pre>
    <p>
      we would just use it as expected, as long annotations have been used as 
      shown above:
    </p>
    <pre>  Value v = objectMapper.readValue(json, Value.class);</pre>
    <p>
      and it &quot;just works&quot;
    </p>
    <p>
      <b>2.4 Ergonomics: Simpler, more powerful configuration</b>
    </p>
    <p>
      Although ObjectMapper's immutable friends -- <b><i>ObjectReader</i></b> 
      and <b><i>ObjectWriter</i></b> -- were introduced much earlier, 2.0 will 
      give more firepower for both, making them in many ways superior to use 
      of <i>ObjectMapper</i>. In fact, while you can still pass ObjectMappers 
      and create ObjectReaders, ObjectWriters on the fly, it is recommend that 
      you use latter if possible.
    </p>
    <p>
      So what was the problem solved? Basically, <u><i>ObjectMapper is 
      thread-safe if (and only if!) it is fully configured before its first use</i></u>. 
      This means that you can not (or, at least, not supposed) to try to 
      change its configuration once you have used it. To further complicate 
      things, some configuration options would work even if used after first 
      read or write, whereas others would not, or would only work in seemingly 
      arbitrary cases (depending on what was cached).
    </p>
    <p>
      On the other hand, ObjectReader and ObjectWriter are fully immutable and 
      thus thread-safe, but would also allow creation of newly configured 
      instances. But while this allowed handling of some cases -- such as that 
      of using different JSON View for deserialization -- number of methods 
      available for reconfiguration was limited.
    </p>
    <p>
      Jackson 2.0 adds significant number of new fluent methods for 
      ObjectReader and ObjectWriter to reconfigure things; and most notably, 
      it is now possible to change serialization and deserialization features (<i>SerializationFeature</i>, 
      <i>DeserializationFeature</i>, as noted earlier). So, to, say, serialize 
      a value using &quot;pretty printer&quot; you could use:
    </p>
    <pre>  ObjectWriter writer = ObjectMapper.writer(); // there are also many other convenience versions...
  writer.withDefaultPrettyPrinter().writeValue(resultFile, value);</pre>
    <p>
      or to enable &quot;root element&quot; wrapping AND specifying alternative wrapper 
      property name:
    </p>
    <pre>  String json = writer
    .with(SerializationFeature.WRAP_ROOT_VALUE)
    .withRootName(&quot;wrapper&quot;)
    .writeValueAsString(value);</pre>
    <p>
      basically, anything that can work on per-call basis will now work 
      through either ObjectReader (for deserialization) or ObjectWriter (for 
      serialization).
    </p>
    <p>
      <b>2.5 Feature parity: JSON Views for deserialization</b>
    </p>
    <p>
      One of frustrations with Jackson 1.x has been that all filtering 
      functionality has been limited to serialization side. Not any more: it 
      is now possible to use JSON Views for deserialization as well:
    </p>
    <pre>  Value v = mapper
   .reader(Value.class)
   .withView(MyView.class) 
   .readValue(json);</pre>
    <p>
      and if input happened to contain properties not included in the view, 
      values would be ignored without setting matching POJO properties.
    </p>
    <p>
      <b>2.6 Custom annotations using Annotation Bundles</b>
    </p>
    <p>
      Another ergonomic feature is so-called &quot;annotation bundles&quot;. Basically, 
      by addition of meta-annotation @JacksonAnnotationsInside, it is now 
      possible to specify that annotations from a given (custom) annotations 
      should be introspected and used same way as if annotations were directly 
      included. So, for example you could define following annotation:
    </p>
    <pre>  @Retention(RetentionPolicy.RUNTIME)
  @JacksonAnnotationsInside
  @JsonInclude(Include.NON_NULL) // only include non-null properties
  @JsonPropertyOrder({ &quot;id&quot;, &quot;name&quot; }) // ensure that 'id' and 'name' are always serialized before other properties
  private @interface StdAnnotations</pre>
    <p>
      and use it for POJO types as a short-hand:
    </p>
    <pre>  @StdAnnotations
  public class Pojo { ... }</pre>
    <p>
      instead of separately adding multiple annotations.
    </p>
    <p>
      <b>2.7 @JsonUnwrapped.prefix / suffix</b>
    </p>
    <p>
      One more cool new addition is for <i>@JsonUnwrapped</i> annotation 
      (introduced in 1.9). It is now possibly to define prefix and/or suffix 
      to use for &quot;unwrapped&quot; properties, like so:
    </p>
    <pre>  public class Box {
    @JsonUnwrapped(prefix=&quot;topLeft&quot;) Point tl;
    @JsonUnwrapped(prefix=&quot;bottomRight&quot;) Point br;
  }
  public class Point {
    int x, y;
  }</pre>
    <p>
      which would result in JSON like:
    </p>
    <pre>  {
   &quot;topLeft.x&quot; : 0,
   &quot;topLeft.y&quot; : 0,
   &quot;bottomRight.x&quot; : 100,
   &quot;bottomRight.y&quot; : 80  
  }</pre>
    <p>
      This feature basically allows for scoping things to avoid naming 
      collisions. It can also be used for fancier stuff, such as binding of 
      'flat' properties into hierarchic POJOs... but more on this in a 
      follow-up article.
    </p>
    <p>
      <b>3.0 And that's most of it, Folks!</b>
    </p>
    <p>
      At least for now. Stay tuned!
    </p>
    <p>
      <b>EDIT</b>:
    </p>
    <p>
      Links to the continuing &quot;Jackson 2.0 saga&quot;:
    </p>
    <ul>
      <li>
        <a href="http://www.cowtowncoder.com/blog/archives/2012/03/entry_467.html">XML 
        with Jackson 2.0</a>
      </li>
      <li>
        <a href="http://www.cowtowncoder.com/blog/archives/2012/03/entry_468.html">CSV 
        with Jackson 2.0</a>
      </li>
    </ul></p>
     <p class="entry-footer">
          <span class="post-footers">Posted by Tatu Saloranta  at Monday, March 26, 2012 10:19 PM </span>
<br />     Categories: <a href="http://www.cowtowncoder.com/blog/archives/cat_java.html">Java</a>, <a href="http://www.cowtowncoder.com/blog/archives/cat_json.html">JSON</a>
<br />
<span class="separator">|</span> <a class="permalink" href="http://www.cowtowncoder.com/blog/archives/2012/03/entry_466.html">Permalink</a>
<span class="separator">|</span><a href="http://www.cowtowncoder.com/blog/archives/2012/03/entry_466.html#disqus_thread">Comments</a>
<BlogItemBacklinksEnabled> | <a href="http://www.cowtowncoder.com/blog/archives/2012/03/entry_466.html#links">links to this post</a></BlogItemBacklinksEnabled> 

     </p>
          </div>
     </div>
</div>
   
     <h2 class="date-header">Tuesday, October 11, 2011 </h2>
<div class="entry" id="post-463">
     <h3 class="entry-header">Jackson 1.9 new feature overview</h3>
     
     <div class="entry-content">
          <div class="entry-body">
               <p><p>
      Jackson 1.9 was just released. As usual, it can downloaded from the <a href="http://wiki.fasterxml.com/JacksonDownload">Download 
      page</a>, and detailed release information can be found from <a href="http://wiki.fasterxml.com/JacksonRelease19">1.9 
      release page</a>.
    </p>
    <p>
      Let's have a look into contents of this release.
    </p>
    <p>
      <b>1. Overview</b>
    </p>
    <p>
      One of focus areas on this release was once again to tackle oldest 
      significant issues and improvement ideas; and two of major new features 
      are long-standing issues (ability to inline/unwrap JSON values; unify 
      annotation handling for getters/setters/fields). Another big goal was to 
      improve ergonomics: to simplify configuration, shorten commonly used 
      usage patterns and so on. And finally there was also intent to try to 
      &quot;2.0 proof&quot; things, by trying to figure out things that need to be 
      deprecated to allow removal of obsolete methods as well as indicate 
      cases where improved functionality is available.
    </p>
    <p>
      <b>2. Major features</b>
    </p>
    <p>
      (note: classification of features into major, medium and minor 
      categories is not exact science, and different users might consider 
      different things more important than others -- here we simply use 
      categorization that the release page uses)
    </p>
    <p>
      Major features included in 1.9 are:
    </p>
    <ul>
      <li>
        Allow inlining/unwrapping of child objects using @JsonUnwrapped
      </li>
      <li>
        Rewrite property introspection part of framework to combine 
        getter/setter/field annotations
      </li>
      <li>
        Allow injection of values during deserialization
      </li>
      <li>
        Support for 'external type id' by adding 
        @JsonTypeInfo.As.EXTERNAL_PROPERTY
      </li>
      <li>
        Allow registering instantiators (ValueInstantiator) for types
      </li>
    </ul>
    <p>
      <b>2.1 @JsonUnwrapped</b>
    </p>
    <p>
      Ability to map JSON like
    </p>
    <pre>  {
    &quot;name&quot; : &quot;home&quot;,
    &quot;latitude&quot; : 127,
    &quot;longitude&quot; : 345
  }</pre>
    <p>
      to classes defined as:
    </p>
    <pre>  class Place {
    public String name;<br><br>    @JsonUnwrapped
    public Location location;
  }
<br>  class Location {
   public int latitude, longitude;
  }</pre>
    <p>
      has been on many users' wish list for a while now; and with addition of 
      @JsonUnwrapped (used as shown above) this simple structural 
      transformation can now be achieved without custom handling
    </p>
    <p>
      <b>2.2 &quot;Unified&quot; properties, merging (&quot;sharing&quot;) of annotations of 
      getters/setters/fields</b>
    </p>
    <p>
      Another long-standing issue has been that of isolation between 
      annotations used by getters, setters and fields. Basically annotation 
      added to a getter was only ever used for serialization, and would never 
      have any effect on deserialization; similarly setter never affected 
      deserialization. While this is not a problem for many annotation use 
      cases, it would make following use case work quite different from what 
      users intuitively expect:
    </p>
    <pre>  class Point {<br>    @JsonProperty(&quot;width&quot;)<br>    public int getW();<br>    public void setW(int w); // must be separately renamed<br>  }</pre>
    <p>
      which would actually lead to there being two separate properties: 
      &quot;width&quot; that is written out during serialization; and &quot;w&quot; that is 
      expected to be received when deserializing. Many users would intuitively 
      expect annotation to be &quot;shared&quot; between two parts of logically related 
      accessors. Same issue also affects annotations like @JsonIgnore and 
      @JsonTypeInfo, requiring use of seemingly redundant annotations.
    </p>
    <p>
      Jackson 1.9 solves this by adding new internal representation of logical 
      property, and merging resulting annotations using expected priorities 
      (meaning that annotations on a getter have precedence over setter when 
      serializing, and vice versa).
    </p>
    <p>
      There are also other more subtle changes, related to these changes. For 
      example, class like:
    </p>
    <pre>  class ValueBean {
    private int value;

    public int getValue() { return value; }
  }</pre>
    <p>
      can now be deserialized succesfully, even without field &quot;value&quot; being 
      visible or annotated: since it is joined with getter (&quot;getValue()&quot;), and 
      getter is explicitly annotated, field is included as the accessor to use 
      for assigning value for the property.
    </p>
    <p>
      The last important benefit of this feature is that now handling of 
      Jackson and JAXB annotations is much more similar, which should make 
      JAXB annotations works better as a result (code was simplified 
      significantly) -- this because JAXB had always considered annotations to 
      be shared in this way.
    </p>
    <p>
      <b>2.3 Value Injection for Deserialization</b>
    </p>
    <p>
      Value injection here means ability to insert (&quot;inject&quot;) values into 
      POJOs outside of general data binding: that is, values that do not come 
      from JSON input. Instead, values to inject are specified during 
      configuration of ObjectMapper or ObjectReader used for data binding.
    </p>
    <p>
      Why is this needed? Some Java types require additional context 
      information to be able to construct POJO instances, for example. And in 
      other cases, you may want to pre-populate values of some fields; and 
      while there are other mechanims (for example, you can pass an existing 
      POJO instance for &quot;updateValue()&quot;) method) they are quite limited.
    </p>
    <p>
      Only two things are needed for value injection:
    </p>
    <ol>
      <li>
        Means to indicate properties for which values are to be injected, and
      </li>
      <li>
        Definition of values to inject
      </li>
    </ol>
    <p>
      Default mechanism is to handle first part by using new annotation, <i>@JacksonInject</i>, 
      so that we could have:
    </p>
    <pre>  public class InjectableBean
  {
    @JacksonInject(&quot;seq&quot;) private int sequenceNumber;
    public String name;
  }</pre>
    <p>
      and second part is handled by allowing configuration of ObjectMapper or 
      ObjectWriter instance with <i>InjectableValues</i>, object that can find 
      values to inject given value id. Value ids can be specified as either 
      Strings, or as Classes; if Class is used, Class.getName() is used to get 
      actual String id to use. For above POJO, we could handle deserialization 
      as follows:
    </p>
    <pre>  ObjectMapper mapper = new ObjectMapper();
  Integer sequenceNumber = SequenceGenerator.next(); // or whatever
  InjectableValues inject = new InjectableValues.Std()
   .addValue(&quot;seq&quot;, id)
  final String json = &quot;{\&quot;name\&quot;:\&quot;Lucifer\&quot;}&quot;;
  InjectableBean value = mapper.reader(InjectableBean.class).withInjectableValues(inject).readValue(json);</pre>
    <p>
      For more on this feature, check out FasterXML Wiki's entry on <a href="http://wiki.fasterxml.com/JacksonFeatureValueInjection">Value 
      Injection</a>.
    </p>
    <p>
      <b>2.4 External Type Id</b>
    </p>
    <p>
      Jackson has had support for full polymorphic type handling since 1.5, 
      allowing configuration of both type identifier in use (usually either a 
      class name, or logical type name) and type inclusion mechanism (as 
      property, as wrapper array, as single-element wrapper object).<br>This 
      covers wide range of usage scenarios, but there is one inclusion 
      mechanism that is sometimes used but could not be supported by Jackson: 
      that of using &quot;external type identifier&quot;. This style of type inclusion 
      is used by some data formats, most notably geoJSON.
    </p>
    <p>
      By external type identifier we mean case such as this:
    </p>
    <pre> {
  &quot;type&quot; : &quot;rectangle&quot;,
  &quot;shape&quot; :  {
   &quot;width&quot;: 20.0,
   &quot;height&quot; : 40.0
  }
 }</pre>
    <p>
      where type is included as a property (&quot;type&quot;) that is outside of JSON 
      Object being typed.
    </p>
    <p>
      With 1.9 we can support such use case by using @JsonTypeInfo with a new 
      inclusion value:
    </p>
    <pre>  public class ShapeContainer
  {
    @JsonTypeInfo(use=Id.NAME, include=As.EXTERNAL_PROPERTY, property=&quot;type&quot;)
    public Shape shape;    
  }
 <br>  static class Shape { }
<br>  @JsonTypeName(&quot;rectangle&quot;) // or rely on class name, Rectangle
  static class Rectangle extends Shape {
    public double width, height;
  }</pre>
    <p>
      One thing to note here is that this inclusion mechanism should only be 
      used with properties; annotating classes with @JsonTypeInfo that 
      indicates external type identifiers can cause conflicts.
    </p>
    <p>
      <b>2.5 Value instantiators</b>
    </p>
    <p>
      And last but not least, 1.9 also allows much more control over mechanism 
      used to create actual POJO value instances. While Jackson 1.2 added 
      support for @JsonCreator annotation, there has not been a way to add 
      custom creator objects.
    </p>
    <p>
      With 1.9, we get following pieces:
    </p>
    <ul>
      <li>
        <i>ValueInstantiator</i> (abstract class), extended by objects used to 
        create value instances
      </li>
      <li>
        <i>ValueInstantiators</i> (interface), provider for per-type 
        ValueInstantor instances (as well as ValueInstantiators.Base abstract 
        class for actual implementations)
      </li>
      <li>
        <i>Module.setupContext</i> method <i>addValueInstantiators</i>(); as 
        well as <i>SimpleModule</i> method <i>addValueInstantiator</i>(), for 
        adding provider(s), so modules can easily provide instantiators for 
        types they support
      </li>
      <li>
        <i>@JsonValueInstantiator</i> annotation that can be used as an 
        alternative to specify instantiator used for annotated type.
      </li>
    </ul>
    <p>
      Above pieces are basically enough to support all three modes of 
      construction @JsonCreator allows (so basically @JsonCreator could be 
      implemented as module, if we wanted!):
    </p>
    <ol>
      <li>
        &quot;Default&quot; construction that takes no arguments and uses no-argument 
        constructor or factory method
      </li>
      <li>
        &quot;Delegate-based&quot; construction, in which JSON value is first bound to 
        an intermediate type (such as java.util.Map or Jackson JsonNode), and 
        this instance is passed to single-argument creator method
      </li>
      <li>
        &quot;Property-based&quot; construction, in which one or more named values (JSON 
        properties) are bound to specified types that match creator arguments, 
        and these are passed to creator method.
      </li>
    </ol>
    <p>
      Mapping of above construction methods to ValueInstantiator methods is 
      fairly straight-forward:
    </p>
    <ol>
      <li>
        Simple no-arguments construction (<i>ValueInstantiator.createUsingDefault()</i>): 
        used if the other construction mechanisms are not available: consumes 
        no JSON properties.
      </li>
      <li>
        Delegate-based construction (<i>ValueInstantiator.createUsingDelegate</i>(Object)): 
        similar to annotating a single-argument constructor or factory method 
        with @JsonCreator, but NOT specifying argument name with 
        @JsonProperty. If specified (i.e. value instantiator indicates it 
        supports this), JSON value for property is first bound into 
        intermediate (delegate) type, and then this value is passed to 
        delegate creator method. Jackson mapper will handle all the details of 
        initial binding, passing delegate object as the argument.
      </li>
      <li>
        Property-based construction (<i>ValueInstantiator.createFromObjectWith</i>(Object[] 
        args)): similar to using @JsonCreator with arguments that all have 
        @JsonProperty annotation to specify JSON property name to bind.
      </li>
    </ol>
    <p>
      It is worth noting that order in which availability of different modes 
      is checked is reverse of above: first a check is made to see if 
      property-based method is available; if not, then delegate-based, and 
      finally default construction.
    </p>
    <p>
      Since this is possibly the most complicated new feature, I will need to 
      defer a full example to another blog post. But let's consider a very 
      simple ValueInstantiator implementation that just supports the default 
      (no-argument) instantiation:
    </p>
    <pre>  class SimpleInstantiator extends ValueInstantiator
  {
    @Override public String getValueTypeDesc() { // only needed for error messages
      return MyType.class.getName();
    }

    @Override // yes, this creation method is available
    public boolean canCreateUsingDefault() { return true; }

    @Override
    public MyType createUsingDefault() {
      return new MyType(true);
    }
  }</pre>
    <p>
      and similarly you can add support for delegate- or property-based 
      methods.
    </p>
    <p>
      <b>3. Other notable features</b>
    </p>
    <p>
      Aside from above-mentioned major features, there are many other useful 
      improvements:
    </p>
    <ul>
      <li>
        &quot;mini-core&quot; jar (jackson-mini-1.9.0.jar)
      </li>
      <li>
        <i>DeserializationConfig.Feature.UNWRAP_ROOT_VALUE</i>
      </li>
      <li>
        @JsonView for JAX-RS methods to return a specific <i>JsonView</i>
      </li>
      <li>
        Terse(r) Visibility: <i>ObjectMapper.setVisibility()</i>, <i>VisibilityChecker.with(Visibility)</i>
      </li>
      <li>
        Add standard naming-strategy implementation(s)
      </li>
      <li>
        Add <i>JsonTypeInfo.defaultSubType</i> property to indicate type to 
        use if class id/name missing
      </li>
      <li>
        Add <i>SimpleFilterProvider.setFailOnUnknownId()</i> to disable 
        throwing exception on missing filter id
      </li>
    </ul>
    <p>
      &quot;Mini core&quot;: as name suggests, there is now a new jar 
      (jackson-mini-1.9.0.jar) that is about 40% smaller than the default one 
      -- about 136kB or so. Size reduction is achieved by leaving out text 
      files (LICENSE), as well as annotations, but otherwise functionality is 
      equivalent to standard core package, i.e. supports streaming API 
      (JsonParser/JsonGenerator, JsonFactory).
    </p>
    <p>
      <i>DeserializationConfig.Feature.UNWRAP_ROOT_VALUE</i> is counterpart to <i>SerializationConfig.Feature.WRAP_ROOT_VALUE</i>; 
      and there is also now a new annotation -- <i>@JsonRootName </i>-- that 
      can be used to use custom wrapper name instead of the simple class name. 
      This is useful with interoperability, as some frameworks insist on 
      adding such wrappers.
    </p>
    <p>
      One of few improvements to JAX-RS provider is that now you can add 
      @JsonView annotation to JAX-RS resource methods, and if one is found, it 
      will be set as the active Serialization View during serialization of the 
      result value.
    </p>
    <p>
      One nice ergonomic improvement is the ability to use much more compact 
      configuration methods for changing default introspection visibility 
      levels.<br>For example, you can use:
    </p>
    <pre>  objectMapper.setVisibility(JsonMethod.FIELD, JsonAutoDetect.Visibility.ANY);</pre>
    <p>
      to make all fields auto-detectable, regardless of their visibility. Or, 
      to prevent all auto-detection, you could use:
    </p>
    <pre>  objectMapper.setVisibilityChecker(m.getVisibilityChecker()
  	.with(JsonAutoDetect.Visibility.NONE));</pre>
    <p>
      An improvement to naming strategy support is inclusion of one &quot;standard&quot; 
      naming strategy -- CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES -- which 
      converts between standard Java Bean names (that setters and getters 
      use), and C-style names (like used by Twitter). You can enable this 
      converter by:
    </p>
    <pre>  mapper.setPropertyNamingStrategy(PropertyNamingStrategy.CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES);</pre>
    <p>
      and from there on, can consume JSON like:
    </p>
    <pre> { &quot;first_name&quot; : &quot;Joe&quot; }<br></pre>
    <p>
      to bind to class like:
    </p>
    <p>
      public class Name { public String firstName; }
    </p>
    <p>
      without having to use @JsonProperty to fix name mismatch.
    </p>
    <p>
      As to sub-typing, you can now use new @JsonTypeInfo property 
      defaultSubType to indicate, as name suggests, default sub-type to use in 
      case where type name was missing or could not be resolved: use it like:
    </p>
    <pre>  @JsonSubType(use=Id.NAME, include=As.PROPERTY, defaultSubType=GenericImpl.class)
  public abstract class BaseType { }</pre>
    <p>
      And finally, one improvement to Json Filter functionality is ability to 
      specify that it is ok to use a filter id that does not refer to an 
      actual filter (i.e. can not be resolved by the currently configured 
      filter provider) -- use 'SimpleFilterProvider.setFailOnUnknownId(false)' 
      to make this the default behavior. Missing filter is then assumed to 
      mean &quot;no filtering&quot;, that is, serialization is handled as if no filter 
      was specified.
    </p></p>
     <p class="entry-footer">
          <span class="post-footers">Posted by Tatu Saloranta  at Tuesday, October 11, 2011 8:21 PM </span>
<br />     Categories: <a href="http://www.cowtowncoder.com/blog/archives/cat_java.html">Java</a>, <a href="http://www.cowtowncoder.com/blog/archives/cat_json.html">JSON</a>
<br />
<span class="separator">|</span> <a class="permalink" href="http://www.cowtowncoder.com/blog/archives/2011/10/entry_463.html">Permalink</a>
<span class="separator">|</span><a href="http://www.cowtowncoder.com/blog/archives/2011/10/entry_463.html#disqus_thread">Comments</a>
<BlogItemBacklinksEnabled> | <a href="http://www.cowtowncoder.com/blog/archives/2011/10/entry_463.html#links">links to this post</a></BlogItemBacklinksEnabled> 

     </p>
          </div>
     </div>
</div>
   
     <h2 class="date-header">Wednesday, September 28, 2011 </h2>
<div class="entry" id="post-461">
     <h3 class="entry-header">Advanced filtering with Jackson, Json Filters</h3>
     
     <div class="entry-content">
          <div class="entry-body">
               <p><p>
      I wrote a bit earlier on &quot;<a href="/blog/archives/2011/02/entry_443.html">filtering 
      properties with Jackson</a>&quot;. While it was comprehensive in that all 
      main methods of filtering were covered, there wasn't much depth. 
      Specifically, only very basic usage of Json Filters (<i>@JsonFilter</i> 
      annotation, <i>SimpleFilterProvider</i> as provider) was considered. 
      This approach does allow more dynamic filtering than, say, <i>@JsonView</i>, 
      but it is still somewhat limited. So let's consider more advanced 
      customizability.
    </p>
    <p>
      <b>1. Refresher on Json Filters</b>
    </p>
    <p>
      Ok, so the basic idea with Json Filters is that:
    </p>
    <ol>
      <li>
        Classes can have an associated Filter Id, which defines logical filter 
        to use.
      </li>
      <li>
        A provider is needed to get the actual filter instance to use, given 
        id: this will be configured by assigning a FilterProvider (such as 
        'SimpleFilterProvider') to ObjectMapper or ObjectWriter.
      </li>
      <li>
        Jackson will dynamically (and efficiently) resolve filter given class 
        uses, dynamically, allowing per-call reconfiguration of filtering.
      </li>
    </ol>
    <p>
      From this it is clear that there are 2 main things you can configure: 
      mechanism that is used to find Filter id of a given class, and mechanism 
      used for mapping this id to actual filter used (implementation of which 
      can be as complicated as you want).
    </p>
    <p>
      So let's have a look at both parts.
    </p>
    <p>
      <b>2. Configuring mapping from id to filter instance</b>
    </p>
    <p>
      Of mechanisms, latter one may be easier to understand and use: one just 
      has to implement '<i>FilterProvider</i>', which has but one method to 
      implement:
    </p>
    <pre>  public abstract class FilterProvider {
    public abstract BeanPropertyFilter findFilter(Object filterId);
  }</pre>
    <p>
      given this, 'SimpleFilterProvider' is little more than a <i>Map&lt;String,BeanPropertyFilter&gt;</i>, 
      except for adding couple of convenience factory methods that build 
      'SimpleBeanPropertyFilter' instances given property names, so you 
      typically just instantiate one with calls like:
    </p>
    <pre>  SimpleBeanPropertyFilter filter = SimpleBeanPropertyFilter.filterOutAllExcept(&quot;a&quot;));</pre>
    <p>
      which would out all properties except for one named &quot;a&quot;. This filter is 
      then configured with ObjectMapper like so:
    </p>
    <pre>  FilterProvider fp = new SimpleFilterProvider().addFilter(&quot;onlyAFilter&quot;, filter);
  objectMapper.writer(fp).writeValueAsString(pojo);</pre>
    <p>
      which would, then, apply to any Java type configured to use filter with 
      id &quot;onlyAFilter&quot;.
    </p>
    <p>
      <b>3. Configuring discovery of filter id</b>
    </p>
    <p>
      From above example we know we need to indicate classes that are to use 
      our &quot;onlyAFilter&quot;. The default mechanism is to use:
    </p>
    <pre>  @JsonFilter(&quot;onlyAFilter&quot;)
  public class FilteredPOJO {
    //...
  }</pre>
    <p>
      But this is just the default. How so? The way Jackson figures out its 
      annotation-based configuration is actually indirect, and fully 
      customizable: all interaction is through configured '<i>AnnotationIntrospector'</i> 
      object, which amongst other things defines this method:
    </p>
    <pre>  public Object findFilterId(AnnotatedClass ac);</pre>
    <p>
      which is called when serializer needs to determine id of the filter to 
      apply (if any) for given class. Since the default implementation 
      (org.codehaus.jackson.map.introspect.JacksonAnnotationIntrospector) has 
      everything else working fine, what we can do is to sub-class it and 
      override this method.<br>For example:
    </p>
    <pre>  public class MyFilteringIntrospector extends JacksonAnnotationIntrospector
  {
    @Override
    public Object findFilterId(AnnotatedClass ac) {
      // First, let's consider @JsonFilter by calling superclass
      Object id = super.findFilterId(ac);
      // but if not found, use our own heuristic; say, just use class name as filter id, if there's &quot;Filter&quot; in name:
      if (id == null) {
        String name = ac.getName();
        if (name.indexOf(&quot;Filter&quot;) &gt;= 0) {
          id = name;
        }
      }
      return id;
    }
  }</pre>
    <p>
      Above functionality is just to show what is possible, not that it makes 
      sense. Alternatively you could of course define your own annotations to 
      check; or have List of known class names, check class definition or 
      interfaces type implements. The main point is just that you are not 
      limited to using <i>@JsonFilter</i> annotation, but can use pretty much 
      any logic you want, within limits of your coding skills.
    </p>
    <p>
      The only caveat is that the resolution from Class to matching id is only 
      guaranteed to be called once per ObjectMapper; so any variation in 
      filtering of specific class needs to happen at either mapping of id to 
      filter, or within filter itself.
    </p>
    <p>
      <b>4. Don't be afraid of sub-classing (Jackson)AnnotationIntrospector</b>
    </p>
    <p>
      Actually, the key take away might as well be the fact that 
      AnnotationIntrospector is designed to be customizable. It was initially 
      created to allow easy reuse of JAXB annotations (via <i>JAXBAnnotationIntrospector</i>; 
      combining things with <i>AnnotationIntrospector.Pair</i>); but it is 
      also a very powerful general-purpose customization mechanism. But at 
      this point quite underused one at that.
    </p>
    <p>
      <b>5. Addendum</b>
    </p>
    <p>
      Some additional notes based on feedback I received:
    </p>
    <ul>
      <li>
        Custom <i>BeanPropertyFilter</i> implementations are obviously 
        powerful too: not only can they completely change what (if anything) 
        gets written for property, they can base this on all configuration 
        accessible via <i>SerializerProvider</i> which is passed to 
        serializeAsField(): for example, it can check to see what 
        serialization view is available by calling '<i>provider.getSerializationView()</i>'.
      </li>
    </ul>
    <p>
      
    </p></p>
     <p class="entry-footer">
          <span class="post-footers">Posted by Tatu Saloranta  at Wednesday, September 28, 2011 7:38 PM </span>
<br />     Categories: <a href="http://www.cowtowncoder.com/blog/archives/cat_java.html">Java</a>, <a href="http://www.cowtowncoder.com/blog/archives/cat_json.html">JSON</a>, <a href="http://www.cowtowncoder.com/blog/archives/cat_opensource.html">Open Source</a>
<br />
<span class="separator">|</span> <a class="permalink" href="http://www.cowtowncoder.com/blog/archives/2011/09/entry_461.html">Permalink</a>
<span class="separator">|</span><a href="http://www.cowtowncoder.com/blog/archives/2011/09/entry_461.html#disqus_thread">Comments</a>
<BlogItemBacklinksEnabled> | <a href="http://www.cowtowncoder.com/blog/archives/2011/09/entry_461.html#links">links to this post</a></BlogItemBacklinksEnabled> 

     </p>
          </div>
     </div>
</div>
   
            </div>
        </div>
<div id="beta">
  <div id="beta-inner" class="pkg">
<!-- sidebar -->

<!-- Search -->
<div class="module-search module">
<h2 class="module-header">Search</h2>
<hr />

<!-- SiteSearch Google -->

<style type="text/css">
@import url(http://www.google.com/cse/api/branding.css);
</style>
<div class="cse-branding-right" style="background-color:#FFFFFF;color:#000000">
  <div class="cse-branding-form">
    <form action="http://www.google.com/cse" id="cse-search-box">
      <div>
        <input type="hidden" name="cx" value="partner-pub-1467773697956887:yd8k3mcue4v" />
        <input type="hidden" name="ie" value="UTF-8" />
        <input type="text" name="q" size="24" />
        <input type="submit" name="sa" value="Search" />
      </div>
    </form>
  </div>
  <div class="cse-branding-logo">
    <img src="http://www.google.com/images/poweredby_transparent/poweredby_FFFFFF.gif" alt="Google" />
  </div>
  <div class="cse-branding-text">
    Custom Search
  </div>
</div>

<!-- /SiteSearch Google -->
<hr />
</div>

     <div class="module-archives module">
          <h2 class="module-header">Last posts</h2>
          <div class="module-content">
               <ul class="module-list">
                  <li class="module-list-item"><a href="http://www.cowtowncoder.com/blog/archives/2012/08/entry_477.html">Replacing standard JDK serialization using Jackson (JSON/Smile), java.io.Externalizable</a></li><li class="module-list-item"><a href="http://www.cowtowncoder.com/blog/archives/2012/08/entry_476.html">Forcing escaping of HTML characters (less-than, ampersand) in JSON using Jackson</a></li><li class="module-list-item"><a href="http://www.cowtowncoder.com/blog/archives/2012/05/entry_474.html">Jackson Data-binding: Did I mention it can do YAML as well?</a></li><li class="module-list-item"><a href="http://www.cowtowncoder.com/blog/archives/2012/04/entry_473.html">What me like YAML? (Confessions of a JSON advocate)</a></li><li class="module-list-item"><a href="http://www.cowtowncoder.com/blog/archives/2012/04/entry_470.html">Take your JSON processing to Mach 3 with Jackson 2.0, Afterburner</a></li>
               </ul>
          </div>
     </div>
<div class="module-categories module">
          <h2 class="module-header">Categories</h2>
          <div class="module-content">
        <ul>
          
               <a href="http://www.cowtowncoder.com/blog/archives/cat_database.html">Database</a><br />
          
               <a href="http://www.cowtowncoder.com/blog/archives/cat_environment.html">Environment</a><br />
          
               <a href="http://www.cowtowncoder.com/blog/archives/cat_fooddrink.html">Food+Drink</a><br />
          
               <a href="http://www.cowtowncoder.com/blog/archives/cat_general.html">General</a><br />
          
               <a href="http://www.cowtowncoder.com/blog/archives/cat_java.html">Java</a><br />
          
               <a href="http://www.cowtowncoder.com/blog/archives/cat_json.html">JSON</a><br />
          
               <a href="http://www.cowtowncoder.com/blog/archives/cat_music.html">Music</a><br />
          
               <a href="http://www.cowtowncoder.com/blog/archives/cat_opensource.html">Open Source</a><br />
          
               <a href="http://www.cowtowncoder.com/blog/archives/cat_performance.html">Performance</a><br />
          
               <a href="http://www.cowtowncoder.com/blog/archives/cat_philosophic.html">Philosophic</a><br />
          
               <a href="http://www.cowtowncoder.com/blog/archives/cat_rant.html">Rant</a><br />
          
               <a href="http://www.cowtowncoder.com/blog/archives/cat_silly.html">Silly</a><br />
          
               <a href="http://www.cowtowncoder.com/blog/archives/cat_staxmate.html">StaxMate</a><br />
          
               <a href="http://www.cowtowncoder.com/blog/archives/cat_xmlstax.html">XML/Stax</a><br />
          
        </ul>
          </div>
</div>
<div class="module-syndicate module">
     <div class="module-content">
          <a href="http://www.cowtowncoder.com/blog/rss.xml">Subscribe to this blog's feed</a><br />

          [<a href="http://help.blogger.com/bin/answer.py?answer=697">What is this?</a>]
     </div>

</div>
</div>
     <div class="module-archives module">
          <h2 class="module-header">Archives</h2>
          <div class="module-content">
               <ul class="module-list">
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/08-01-2012_08-31-2012.html'>August 2012</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/05-01-2012_05-31-2012.html'>May 2012</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/04-01-2012_04-30-2012.html'>April 2012</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/03-01-2012_03-31-2012.html'>March 2012</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/12-01-2011_12-31-2011.html'>December 2011</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/10-01-2011_10-31-2011.html'>October 2011</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/09-01-2011_09-30-2011.html'>September 2011</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/08-01-2011_08-31-2011.html'>August 2011</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/07-01-2011_07-31-2011.html'>July 2011</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/05-01-2011_05-31-2011.html'>May 2011</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/04-01-2011_04-30-2011.html'>April 2011</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/03-01-2011_03-31-2011.html'>March 2011</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/02-01-2011_02-28-2011.html'>February 2011</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/01-01-2011_01-31-2011.html'>January 2011</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/12-01-2010_12-31-2010.html'>December 2010</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/11-01-2010_11-30-2010.html'>November 2010</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/10-01-2010_10-31-2010.html'>October 2010</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/09-01-2010_09-30-2010.html'>September 2010</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/08-01-2010_08-31-2010.html'>August 2010</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/07-01-2010_07-31-2010.html'>July 2010</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/06-01-2010_06-30-2010.html'>June 2010</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/05-01-2010_05-31-2010.html'>May 2010</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/04-01-2010_04-30-2010.html'>April 2010</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/03-01-2010_03-31-2010.html'>March 2010</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/02-01-2010_02-28-2010.html'>February 2010</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/01-01-2010_01-31-2010.html'>January 2010</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/12-01-2009_12-31-2009.html'>December 2009</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/11-01-2009_11-30-2009.html'>November 2009</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/10-01-2009_10-31-2009.html'>October 2009</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/09-01-2009_09-30-2009.html'>September 2009</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/08-01-2009_08-31-2009.html'>August 2009</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/07-01-2009_07-31-2009.html'>July 2009</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/06-01-2009_06-30-2009.html'>June 2009</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/05-01-2009_05-31-2009.html'>May 2009</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/04-01-2009_04-30-2009.html'>April 2009</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/03-01-2009_03-31-2009.html'>March 2009</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/02-01-2009_02-28-2009.html'>February 2009</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/01-01-2009_01-31-2009.html'>January 2009</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/12-01-2008_12-31-2008.html'>December 2008</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/11-01-2008_11-30-2008.html'>November 2008</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/10-01-2008_10-31-2008.html'>October 2008</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/09-01-2008_09-30-2008.html'>September 2008</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/08-01-2008_08-31-2008.html'>August 2008</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/07-01-2008_07-31-2008.html'>July 2008</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/06-01-2008_06-30-2008.html'>June 2008</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/05-01-2008_05-31-2008.html'>May 2008</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/04-01-2008_04-30-2008.html'>April 2008</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/03-01-2008_03-31-2008.html'>March 2008</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/02-01-2008_02-29-2008.html'>February 2008</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/12-01-2007_12-31-2007.html'>December 2007</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/11-01-2007_11-30-2007.html'>November 2007</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/10-01-2007_10-31-2007.html'>October 2007</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/09-01-2007_09-30-2007.html'>September 2007</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/08-01-2007_08-31-2007.html'>August 2007</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/07-01-2007_07-31-2007.html'>July 2007</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/06-01-2007_06-30-2007.html'>June 2007</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/05-01-2007_05-31-2007.html'>May 2007</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/04-01-2007_04-30-2007.html'>April 2007</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/02-01-2007_02-28-2007.html'>February 2007</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/01-01-2007_01-31-2007.html'>January 2007</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/11-01-2006_11-30-2006.html'>November 2006</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/10-01-2006_10-31-2006.html'>October 2006</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/09-01-2006_09-30-2006.html'>September 2006</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/08-01-2006_08-31-2006.html'>August 2006</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/07-01-2006_07-31-2006.html'>July 2006</a></li>
              
                <li class="module-list-item"><a href='http://www.cowtowncoder.com/blog/archives/06-01-2006_06-30-2006.html'>June 2006</a></li>
              
               </ul>
          </div>
     </div>

<h2 class="module-header">Related Blogs</h2>
<div class="module-content">
(by Author (topics))
               <ul class="module-list">
<li class="module-list-item"><a href="http://netzooid.com/blog/">Dan D</a>
<br />(XFire, Mule)
</li>
<li class="module-list-item"><a href="http://jfarcand.wordpress.com/">Jean-Francois A</a><br /> (Ajax, Comet, Async HTTP)
</li>
<li class="module-list-item"><a href="http://jazzjuice.blogspot.com/">Josh C</a><br />(Judge Mental)
</li>
<li class="module-list-item"><a href="http://weblogs.java.net/blog/kohsuke/">Kohsuke K</a><br />(Relax NG, Sun MSV)
</li>
<li class="module-list-item"><a href="http://saxonica.blogharbor.com/">Michael K</a><br />(xslt, xquery)
</li>
<li class="module-list-item"><a href="http://mult.ifario.us/a">Paul B</a><br />(Haskell, RSS)
</li>
<li class="module-list-item"><a href="http://weblogs.java.net/blog/spericas/">Santiago P-G</a><br />(Glassfish, java.net, JAXP, Xalan)
</li>
               </ul>
</div>
<div class="module-powered module">
     <h2 class="module-header">Powered By</h2>

     <div class="module-content"><!-- powered by -->
<a href="http://thingamablog.sourceforge.net/"><img
 alt="Powered by Thingamablog" src="http://thingamablog.sourceforge.net/images/powered.gif"></a>,
 <br /><a href="http://blogger-templates.blogspot.com">Blogger Templates</a> and
  Discus comments.
     </div>
</div>

<!-- Author desc -->
<div class="module-photo module">
     <div class="module-content"><img src="/picture_library/cowtowncoder.jpg"></div>
</div>
<div class="module-about module">
     <h2 class="module-header">About me</h2>
     <div class="module-content">
       <ul class="module-list">
         <li class="module-list-item">I am known as <strong>Cowtowncoder</strong></li>
         <li class="module-list-item">Contact me at<a href="mailto:cowtowncoder">@yahoo.com</a></li>
       </ul>
Check my <a href="/author-cowtowncoder.html">profile</a> to learn more.
     </div>
</div>

</div>

<!-- Discus comments -->
<script type="text/javascript">
//<![CDATA[
(function() {
	var links = document.getElementsByTagName('a');
	var query = '?';
	for(var i = 0; i < links.length; i++) {
	if(links[i].href.indexOf('#disqus_thread') >= 0) {
		query += 'url' + i + '=' + encodeURIComponent(links[i].href) + '&';
	}
	}
	document.write('<script charset="utf-8" type="text/javascript" src="http://disqus.com/forums/cowtalk/get_num_replies.js' + query + '"></' + 'script>');
})();
//]]>
</script>
<!-- GA -->
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-140287-10");
pageTracker._trackPageview();
} catch(err) {}</script>
</body>
</html>
